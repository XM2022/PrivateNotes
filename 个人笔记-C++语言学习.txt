C++语言零碎知识点倒序(续)↑：

173.指针判空/非空不要记反了：
if(!p)  //判空            if(p)   //判非空
172.C++中空指针值强制为0，所以==0判空是没有问题的；C语言空指针不一定为0，可以为其他空指针常量(罕见)，如：/L，所以==0判空可能出现问题，最好使用==NULL.
171.连续内存的容器对其增删元素等改变容器大小的操作时，时刻注意更新迭代器的有效性.
170.易错点：
(1)某些变量定义语句在调试时被跳过(被编译器优化掉)可能是因为+右边是不定值(如野指针、失效迭代器)，无法用于初始化其他变量.
(2)
...::iterator begin;//未初始化,为不定值
for(auto end=........,begin;....;....)
{
    ........
}
container.insert(begin(),..) //错误！仍为不定值.
排查：本段代码本意是在外部定义一个begin迭代器，之后通过for循环确定其指向.但是，因for语句过长无意中auto定义了一个局部同名begin将外部begin屏蔽导致外部begin循环过后仍未初始化为不定值.
注：insert()参数1使用未定义值编译器器无法发现报错，运行时崩溃.
(3)设i为list容器迭代器，
list1.erase(i);   //应改写为：i=list1.earse(i)将迭代器i更新.
list2.insert(i);  //使用失效迭代器，将导致严重运行时错误，且难以排查.
补充：书上说的是list、forward_list其他位置的迭代器、引用、指针不会失效，但是当前位置迭代器仍然会因元素被删除而失效.

规范：应该同局部变量j=0手动初始化，将i=erase(i)作为日常写法，即便后续不再使用i，依靠习惯的力量避免出现此类错误.
而是否将j=0和i=erase(i)去掉提高性能，留作日后再优化.
(因为此时代码已经定型，容易判断；并且能提高开发效率，正如前辈所说的:"不要一开始考虑优化问题，反正优化了说不定还有重写，给自己前期开发增加思想负担".也如阿弥老师所说："作画先应该把大的结构框架确定后，而不是一开始就死抠细节."学习更是如此.)

169.两个迭代器必须是同一个容器，否则比较将编译不报错，运行崩溃！
因此函数参数应该是引用传递.
168.一些错误是不可预知的、不可再现的！
167.假设array是含3个整型元素数组名，
int *p1 = array;  //正确，数组名自动隐式转换为指向首元素的指针.
int *p2 = &array; //错误！此时array是本义，指向整个数组，对其取地址，是整个数组的地址，含数组的长度信息.
正确写法为: int (*p2)[3] = &array.
可见，数组地址和数组首元素的地址不是同一个概念！后者不能代表前者.
另外，p2仍然是一级指针.
168.文件流和输入输出流：
(1)文件路径可以使用斜杠和反斜杠，但要注意使用\\防止转义字符.(难以发现和排查)
(2)因为fstream(包括ifstream和ofstream)继承自iostream,所以如果没有fstream的重载版本(最佳匹配)，实参将退化(转换)为ostream类型(反之不行).但是！退化后的fstream既失去的之前的文件流功能，也没有(无法正常输入输出)iostream的输入输出功能,因此不建议重载文件流和输入输出流函数，否则一旦没有fstream版本，隐性转换调用iostream版本，没有任何异常和报错！(实际上不符合程序员意图)难以排查.
“前人栽树后人乘凉”，请为这两个流取不同的函数名.
167.试错是为了熟悉编译器的报错，将来更快速的查找定位错误.提高自身的纠错能力，让自己的项目代码落地成为实际，而非空中楼阁、乌托邦.
163.添加删除元素改变容器string、vector、deque容量的操作会导致迭代器(本质指针)、指针、引用(本质const指针)失效的原因：
这些容器是一块连续的内存(支持随机访问的原因)，一旦改变容量就有可能需要整体重新移动到新的内存位置，地址(指针)发生改变.
162.强制类型和void指针全面总结：
(1)static_cast能改变类型,除了指针类型和含底层const类型.(因为顶层const属于值拷贝，会被自动忽略，非引用不需要关注，正常使用static_cast即可).
(2)const_cast能删除/增加底层const常量属性，尝试改变顶层const是未定义、被忽略、无效的！该类型转换只能是指针、引用等含底层const的对象使用.
注意：原本是const对象删除常量属性后，对其进行写修改操作是未定义行为！
(3)reinterpret_cast用于改变指针的类型(恰好与static_cast功能互补).值得一提的是，可以增加到不能删除底层const！因此，可以说该转换具有const_cast一半的功能，但不能替代static_cast的类型转换功能.(顶层const未知，也无法没有必要和意义去关注验证，详见(4)条和示例)
注意：指针类型的转换与修改指针底层const相比，前者与机器相关，更具有危险性！
(4)这三者返回的都是值传递/拷贝/右值，因此若为引用，恒使用const(常量)引用.
注意：对象2 = const/static.._cast<>(转换对象)；该赋值语句不会改变转换对象自身的类型！改变通过返回改变类型后对象的拷贝赋值给对象2(不同类型).如果对象2是自身将会引发错误！自身类型已经在定义时确定，无法改变！
(5)旧式强制转换风格：
type(转换对象);  //函数形式，局限性很大，只能进行单一类型转换.
(type)对象;  //常用形式，这种形式可以实现以上三种强制转换.
新旧格式优缺点：
新风格有三种格式，每种格式功能做了限制，使得使用起来目的明确，使得程序代码阅读起来对程序员的使用意图明确.
旧风格简洁灵活，相比于新风格使用起来方便，这既是它的优点也是它的缺点.它的一种格式可以实现了三种功能，这使得程序代码意图不明确，尤其是团队合作的情况下.比如，当时写代码是只想使用const_cast功能删除底层常量属性，无意中前后书写类型不一致，造成同时使用了const_cast和reinterpret两种功能.日后再次回看这段代码，已经忘记当初的意图是仅删除常量属性还是删除常量属性和转变类型.这不得不去追溯大量前后文代码来寻求答案.这无疑极大增加了程序代码维护的工作量和成本.
这就是为什么说“书写规范的程序和可读性好的代码很重要.”
本条示例：
const int * p1;
double *p2;
.
.
.
//已经记不清p1,p2类型,
//此时误认为p1,p2都是double类型,
//意图是：只想删除底层const属性
//便有了如下代码：
p2 = (double*)p1;  //错误：与原意图不符！
//此句使用了两种功能
//等价转换为，
//temp = const_cast<in*>(p1); 
//p2 = reinterpret<double*>(temp);
//前者代码可读性低，无法理解程序员的意图;后者可读性好，意图明确，容易发现错误.
(6)void指针：
首先明确的是空指针(NULL/nullptr)和void*类型指针是完全两种不同的指针.(空指针可以赋值给任何类型的指针.换句话说，空指针可以转化成任何类型！)
任何类型的指针都可以赋值给void*型指针，这一点和c语言一致；但是反过来，因为c++是强类型语言，所以void指针不能自动隐式转化成其他类型指针，必须显示强制转换，这一点和c语言不同.
下面介绍显式转换方法：
int *p;  
void *vp = p;  //自动隐式转换
p = reinterpret_cast<void*>(vp);  //新版风格
p = (void*) vp;  //旧版风格
(7)强制转换使用准则：
尽量避免不必要的强制转化.要进行强制转换，说明程序设计存在缺陷.reinterpret_cast能够还原void*的指针原本保存的地址信息。这种转换还是有必要的，但是其操作本身就很危险，一旦转换的类型与原本类型不符，编译器后续操作将按照此错误类型进对数据进行处理，将可能引发严重错误.编译器对这种转换是不进行检查报错的，这导致一旦出错将难以排查.
所以说强制类型转换干扰了编译器后续的类型检查，将类型转换正确性交给程序员负责.

总示例：
int m=5;
const int * const mp=&m;
int *mp2=nullptr;
mp2=const_cast<int* (const/无)>(mp); //正确：删除了底层const, ()中的内容(顶层const)无论有无均被编译器忽略(见(2)条)
下面是引用类型说明：
顶层const对引用有效，但是这不意味着你使用const_cast需要关注顶层const.
int * &const mp3=const_cast<int*(const/无)>(mp);  //&后面这个const无论原对象顶层const是否存在，必须写上！因为(4)条，非左值的引用必须是常量引用(右值本质是一个(静态)局部拷贝值，不能被修改)；同上个例子，()中的内容可有可无.因此const_cast中引用无需关注考虑顶层const,恒为const引用！

题外话：
(0)使用static_cast<type>(expr)、const_cast<type>(expr)、reinterpret_cast<type>(expr)这三者请按照格式书写，缺少<>和()均会报错.
(0.1)type转换类型亲测可以和原本类型一样，属于无意义、画蛇添足的傻逼行为！

161.数组名和auto的三种情况：
int arri[5]={};  //定义一个5元素的整型数组
(1)auto a=arri;  //推断出的是int*类型
(2)for(auto a : arri) //推断出int类型；范围for()中auto是特例，推断出的是元素值的类型(因为范围for用于输出容器的元素值)；通过a访问的是数组元素的拷贝.
(3)for(auto &a : arri)//推断出int[5](数组名本义)；auto&数组名不会发生转换(退化)指向首元素的指针，a整体是数组的引用，通过a访问的是数组元素本身，符合&(引用)本义.
注：decltype()推断出类型同情况3.
160.数组只有在定义初始化时未赋值的元素自动初始化为0.一旦未初始化，必须全部赋值，否则剩余元素为不定值.然而全部赋值容易产生遗漏或越界，十分危险.
建议定义局部数组时同时初始化.
注：C++支持int arri[5]={}简洁初始化写法.
159.如果一个声明没有被调用，那么编译器就不会在意它是否真的有定义.
158.int i=5;  const/constexpr i2=5;
 int arri[i]; //错误！数组定义必须为常量
 int arri[i2]; //正确.另外可以给数组元素加const限定不可修改.
157.输入与缓冲区总结：
cin输入错误会返回0并赋值(错误！不会被接收.)给该处接受变量.之后终止后续(不接收)输入，故后续接受输入变量保持输入前的值不变(错误–正确！).
--修正补充：cin输入流的返回值实际上就是goodbit(与failbit无关).输入错误后输入流返回0，并且该错误输入值不被接收，仍滞留在缓冲区.也就是说，此处开始(包括此处)后续所有(同类型)的变量保持输入前的值.   注意：int不接收char类型，会造成输入错误，即使能隐式转换.
cin––在有限输入之前，空白符(空格、制表符、回车)均被忽略.回车作为输入终止符(前提存在有效输入).有效输入满足后，后续所有的字符均被忽略而被残留在缓冲区.此方式不能读入空格符、制表符，因为它们作为输入的分隔符.另外，cin所有输入均会有一个回车符残留.所以如果下一个输入是cin>>char或者getline会造成输入出错.因此，使用cin要保持缓冲区清理习惯，让输入程序更健壮.
getline(cin, 变量)––读入一整行，包含空格和制表符，回车键作为输入分隔/终止符,并读取丢弃.因此，此方式缓冲区无残留.

易错点实例：
int a=0;
cin>>a;   
输入：2didjen
结果：输入正确，流返回为真.
解释：咋一看变量是int,而输入有字符，好像输入有误.实则2作为有效输入后，后面的字符均被忽略，残留在缓冲区.

if(cin>>int)
输入:0
结果：条件判断为真.
解释：输入流的返回值(goodbit)是由输入状态是否正常决定，而不是输入值(0).

156.求值顺序和结合律是两码事，大多数运算符都没有规定求值顺序！
155.运算符重载只能改变运算对象类型和返回值类型，不能改变运算符的运算数量、优先级和结合律.
换句话说，重载运算符的运算数量、优先级以及结合律和默认内置版本是一致的.
154.代码能自己规范优化的，不要交给编译器帮你纠正.很多时候，除非强大的编译器，否则自动优化比不上手动优化，在程序员看似很容易识别的优化，对于编译器来说不一定.就像人能够轻易识别图片，而机器识别则需要复杂的算法和大量的学习.很多复杂场景编译器无法识别，或者需要花费很多时间.请将编译器作为最后一道底线，不要轻易触碰.
153.const函数只有类成员函数可以使用，相应的函数返回值如果为本对象引用必须是常量引用，且通过该函数赋值引用话，也必须为常量引用.另外，const成员函数(函数体)内、外(返回值)都不允许改变对象成员.
152.同一表达式中两次及以上调用同个对象并且修改将引发未定义行为！
151.数据之所以要定义类型，是因为只有明确了类型，才知道每个数据所占用内存空间的大小.由此可知，数组中和数组尾元素的下一位置是确定的，再往后因为不属于数组类型管辖，分段大小无法确定，所以int arr[5]; int *p=a[5]//尾指针，正确，但不能解引用来使用.int *p2arr[6]//严重错误，无法确定其指向位置.
150.类的定义放在头文件.如果放在源文件，头文件只有类声明，是不完全类型.
同样，内联函数也行放在头文件，否则没有定义无法在指定处展开(属于广义的不完全类型).
149.为了效率，C++默认初始化规则：只对全局(静态和非静态)变量和局部静态进行初始化，局部非静态变量不进行初始化，即：
全局变量会自动初始化为0，局部静态变量也会自动初始化为0，局部非静态变量未初始化为不定值！

￼
148.很多STL容器、算法都要求，被使用类有默认构造函数.因此，即使默认值没有意义，仍建议提供默认构造函数.
147.动态指针判断一定要加，静态的在正式版本发布时可以拆除检测设施.
146.仔细观察下图实际类函数返回值易错点并牢记

145.关于委托构造函数：
(1)初始化列表有委托构造
144.报错汇总：
(1)"无法解析的外部符号"–"1个无法解析的外部符号"：这一对报错说明找到了声明，但是只有声明没有定义；或者是声明和定义处名字不对应(打错)造成没有定义.
(2)另一个相似的报错"未定义表示符"：
根本没有找到这个声明.(一般由于名字打错)
143.对于类，先按顺序处理全部声明(包括函数声明和成员变量定义)，然后再处理函数定义/函数体.
根据此处理逻辑，可明白：1.即使成员变量定义在后，函数体内仍可见全部成员变量；2.对于函数声明部分(返回值和形参)，类型别名定义必须提前可见.
142.为了与C语言兼容，字符串字面值("")与string类不是同一个类型，但字符字面值和字符串字面值能够自动隐式转换成string.
141.仅有声明的类是不完全类型，仅能用作函数的形参类型和返回值、该类指针、该类引用，但不能通过这些访问其成员.另外，类中定义成员可以是本类类型指针或引用，但不能是本类类型.
140.函数返回值是引用是才能作为左值.
139.全局变量和静态变量存在于全局区/静态区，局部变量存在于栈区，new的对象存在于堆区，malloc的对象存在于自由存储区，常量存在于常量区。
138.常量表达式定义是值不变且能在编译阶段就能确定的表达式.const常量值不变，但初始化可以在运行时确定，所以const常量组成的表达式不一定是常量表达式.
137.与auto类型不同，decltype()会返回全部类型，不会有所忽略.因为前者需要在求得类型的同时需要作为初值赋给左值，后者只要求得类型即可.两者功能不同，导致实现逻辑不同.另外，注意两点：decltype(*p)和decltype((变量))返回的都是引用类型.
136.auto类型会忽略&和顶层const，所以auto类型不包含引用和*const p两种类型，必须显式指出：auto& 和 const auto
注意：auto&类型不会忽略顶层const,
&const(顶层)变量变成底层指针.
补充：用引用所指的对象作为初值判断类型
135.类成员函数不能在类外声明(闲的没事干，类内本身已经有了)，属于重复声明.
134.普通带默认实参的构造函数实参放在声明处才能生效(定义处实参会被忽略，当成0实参函数处理)，类外定义的普通函数同上，也是类内函数声明才生效.对于类外定义的内联函数，定义或声明处都能生效.
         无论以上哪一种函数，声明和定义处不能同时带默认实参，即使互补型也不行，否则报错！
133.C++中，八进制前缀是0.
014  14  前者是八进制=12，后者是十进制，所以不要随意在十进制数前面加0！
132.数据类型溢出后重新循环取值.如：只能表示0~255，则256转换后为0.
此操作等同于公式：数据％总数(取模/余)
131.再次说明：if(a=value)以赋值完成后a的值判断条件真假.相当于：a=value; if(a);
130.无法生成且需要使用默认构造函数时会报错：
"尝试引用已经删除的函数"
––类类型成员没有默认构造函数导致无法生成本类默认构造函数；
"没有(合适的)默认构造函数"
––本类无法生成默认构造函数(可能已经定义带参构造，或者因为上一条原因).
129.string str = "字符串"；
其中进行了一次隐式转化，因为"字符串"不是C++的string类(应该是const char*).
128.假设p是一个空指针，int &p2=*p就产生了一个空引用，一旦其被使用，会导致程序崩溃！(解引用指针*p也会崩溃.)
127.引用指针： int *(&p1) = p;
拷贝指针： int *p2 = p;
(引用指针没有什么意义，因为引用初衷是避免拷贝大对象带来的性能开销，而指针本身所占内存很小.)
126.constexpr函数中string、const string、string&无论是在形参中还是函数体中定义，都不是文本值/字面值，只有const string&才是,才能编译通过生成常量函数.
125.关于C++的构造函数和类成员初始化：
(1)在没有定义任何构造函数时，编译器才会自动合成默认构造函数，如果能话.
(1.1)若类成员中包含复杂类型(如包含其它类)，且其没有默认(无参)构造函数，则无法合成默认构造函数.
(1.2)默认构造函数优先根据类内初始值值初始化(手动)，否则进行默认初始化(对于内置/复合类型而言为不定值！)
(1.3)根据上条推出：只有类内有初始值，才可以不写构造函数，默认合成.换句话说，定义类成员时尽量同时赋于初始值
(2)类成员有三种获值方式––类内初始值(/默认初始化)；构造函数初始化列表；构造函数函数体.类成员初始化完成时机在执行构造函数之前.也就是说，以上三种方式前两种属于真正意义上的初始化，第三种通过执行函数体，完成对已经初始化成员值的更改.
补充：如果初始化列表中含该成员，则不会执行初始值初始化，没有才通过初始值初始化.这两种方式只会进行其中一种.
124.关于广义局部变量初始值：
(3)局部内置/复合类型非静态变量不通过值初始化(即手动)的话，将执行默认初始化(即自动)，此种方式初始值是不定的！
(1)内置类型如int等，复合类型如数组和指针；C++中string类不属于以上两种类型，因而它的初始值确定，为空字符串("").
(2)局部变量的专业表述为块内区域定义的变量，类成员也属于块内.
(原因在于磁盘硬件的读写方式)
123.不同作用域同名的函数名(本质是一个指针)、变量名会相互隐藏.
所以，变量名和函数名尽量不要重名！形参名和全局变量名也不尽量要重名！成员函数形参名和成员变量名不要重名.
补充：函数内局部变量和传入的同名实参不会相互屏蔽.另外，形参和局部变量不可能同名，因为会报错重定义.
122.关于windows环境变量：
(1)用户环境变量仅对于当前用户可见，系统环境变量对所有用户可见。
(2)设置可以运行程序的环境变量：
方法一：
在PATH(系统、用户均可)环境变量中添加"程序.exe所在文件夹的目录路径(不需要.exe程序名)".
方法二：
新建一个环境变量名(不区分大小写)。将"程序所在的目录路径+.exe程序名"复制内容中。除此之外，不要增加任何额外内容。千万要注意，前后不能带任何分号，否则会报错：文件路径不正确。(必须在"编辑文本"选项下才能真正看到有无分号。)
(3)使用环境变量运行程序:
对于方法一，
Win+R和cmd均可，直接输入程序名(.exe后缀有无均可)，如程序名有空格，必须使用英文双引号将程序名括起来(空格数量要完全一致)，否则无法识别命令.
对于方法二，
只能在Win+R下输入刚才新建的环境变量名(不是程序名：),前后要加上百分号。
121.assert(系统断言)如果运行会屏蔽上一条紧挨的宏定义输出.
120.使用\换行代码，\该行后面不能有任何字符，且下一行空格、制表符(对于字符串而言)均不会忽略.
119.宏定义发生重复以最后一个定义为准
118.重载函数调用二义性判断易错点：
用一个实参调用，对于只有一个形参和含两个形参、其中一个带默认实参：这两个重载函数优先级一样！(即使表面上看第一个函数与调用参数数量更精确匹配)
117.ptr1 = const_cast<const/无>(ptr1);
赋值给自身const_cast表达式将不能生效(无论引用还是指针)，只能新建一个变量接受该式才会生效.
116.函数返回值不能是局部变量的引用或者指针，返回拷贝值可以。
115.头文件和原文件报错汇总：
(1)"无法解析外部命令"和"无法解析外部符号....函数main中引用了该符号"两个错误：
原因：被调/声明函数未定义，因头文件和源文件中函数定义与声明不一致造成.(如：形参含底层const函数声明和定义必须一致.)
(2)"找不到标识符"：
原因：头文件中未包含该被调函数的声明。
(3)"未找到符合条件的重载函数":
原因：调用参数与函数声明形参不匹配。
114.类成员函数中形参同名会屏蔽类成员，普通函数形参和函数体同名局部变量会屏蔽全局变量而不会(也无法)屏蔽外层嵌套函数局部变量.
113.形参含底层const函数声明和定义必须一致.
112.能直接指向绝不通过中间变量指向，能防止很多不必要的修改错误，避免了耦合.
111.常量和引用必须在定义时初始化.
110.每个语言有每个语言的风格，符合该语言的风格才能完全发挥该语言的优势.
例如：用Java风格写C++，不能发挥C++对内存、效率的掌控优势(什么？不追求这一点运行效率？那何必要用C++这门语言，Java开发不必它快？).同理，这也是为什么说不要用C++写C语言代码的原因.
109.转义字符：
[图片 415.jpg]
108.抛出异常：
(1)try和各个catch子句内定义的局部变量相互独立，不共享.
(2)exception()、bad_alloc()、bad_cast()不能填入初始参数(含异常信息的字符串)，其他异常类需要填入.
(3)exception是其他异常的父类，所以catch(exception)写在最后用于万能处理(相当于default)，写在前面则其他catch子句失去了作用.
(4)只有在没有catch语句执行或者手动catch(异常类 temp){cout<<temp.what()}时,
错误信息才会输出显示.
107.const &常量引用虽然失去的引用的最附属功能–改变原变量，但是引用传递不用拷贝，保留了主要效率功能.
106.
[图片 400.jpg]
105.1：承接105条，指针判空推荐写法：
if(nullptr==p)或if(!p);
而不是if(NULL==p);
105.void*是无类型指针，可以指向任何类型数据地址(任何类型指针都可以赋值给它)；
但不能颠倒过来，空指针赋值给其他类型指针必须先进行强制转换(更正：C语言可以将空指针赋值给其他类型，自动隐式转换；C++不可以，因为它是强类型语言(新增模板).
但实际上，C语言的NULL为(void*)0；如果是C++，编译器自动将NULL处理为0，所以两者实际编程都允许使用NULL；但NULL实质是int 0,在函数重载和模板会产生二义性问题:fun1(type*p),fun2(int i)传入NULL会选择后者，故C++11引入了nullptr新关键字(不是单纯的替换为0了).
因为malloc()返回值为void*,
所以int *p = (int*)malloc(sizeof());
104.注意除法自动取整问题：
3/8*num不等同与3*num/8！
3.0/8*num才等于同与3*num/8.
103.二维数组char a[3][4]形参类型为
char a[3][4]或char* a[3];char** a错误！
注意while(a[i++])中a[i]是指向整个一维数组的指针，(地址)永远不为空(不为假).
102.char a[5]="12345"; 
错误！没有预留‘\0’空间，数组将越界！
Dev-C++无报错和警告(老旧编译器)，
VS2019出现报错.
101.字符串用非空值出初始化时，可以不加{}，但全部初始化为0时，必须加{}.
如：   char a[5] = {0};   //或'\0'
100.C语言标准库与平台无关，C运行库是它的超集=标准库+与平台有关的函数.
备注：ANSI标准就是C语言标准.(区别GNU)
99.#if 常量表达式(必须为确定值,非0为真)
     #elif   (与#if配套而非#ifdef,elif仅预编     
                译语句和Python存在C语言没有  
                else if的缩写)
     #endif(和#ifdef、#ifndef结束符相同)
98.#include该预编译命令相当于把许多声明展开粘贴到该位置，由此推得：
1.#include语句放在源文件开头较合理，因为需要在源文件调用前提前声明.
2.#pragma once放在比#include还前面较合理，免去做"声明无用功".
97.宏定义作用域为定义处至当前所在"源文件"的文件结尾或遇#undef提前结束.
宏定义一般写在头文件，方便被多个源文件使用，但要使用#ifndef..#define..#endif防止宏名重复定义.
96.位(bit/b)是计算机中最小的信息单位，
字节(Byte/B)是计算机中储存数据的基本单位，注意两者缩写的不同.
因为存储器内有很多存储单元，一个存储单位可以保存8个(二进制)位，即1个字节(1B=8b),所以存储器容量最小单位是字节.
也就是说，计算机中数据的基本单位是字节.
附：
1B（字节）=8b（位）
1 KB = 1024 B
1 MB = 1024 KB
1 GB = 1024 MB
1TB = 1024GB
95.DEV-C++有时"编译"存在无法识别新改动代码的情况，这是请使用"全部重新编译(F12)".可恶的是，你不知道它什么时候发作！让人摸不着头，以为是代码bug.
备注：宏名更改与注释、头文件声明修改
请按F12"全部重新编译"！
94.缓冲区只有在程序重启才会自动清空
93.strlen()计算字符串长度，sizeof()计算占用内存空间大小；对于C语言风格而言，前者不包含'\0'结束符，后者包含.
92.使用类实例化一个对象时，如果没有参数就不需要加()，因为默认构造函数不需要(),否则变成了返回值为该类的一个普通函数.
91.内置类型(int double等)和复合类型变量只有在全局时才会自动初始化(可能处于效率考虑，而且定义的局部变量习惯上必定在接下来会手动赋值才使用)，否则只声明未初始化的局部变量是不定值！未进行赋值(初始化)就使用它们极其危险！
90.类成员初始化顺序由类内声明顺序决定.
89.有些成员类型(如const和没有默认构造函数)必须在类构造函数初始化列表初始化，
而不能在函数体内进行赋值初始化.

87.注释行只会影响编译速度，不会影响程序运行效率，因为其不会被编译为可执行文件.

85.表达式由运算符和操作数组成，
最简单的语句是表达式加分号(;).
逗号表达式顺序是从左往右，取最后一个表达式作为整个逗号表达式的值.(逗号表达式也可以分成多个语句书写，)
注意：printf("%d",a1,a2,a3)中不是逗号表达式， ，作为分隔符，取第一个变量a1输出
同理，函数()中参数列表中，也只是分隔符
84.exit()需要包含<stdlib.h>,非0异常退出
没有头文件警告:implicit declaration of.....
83.C/C++中使用未赋值初始化的指针，
经常会引起系统崩溃.
82.数组作为函数参数：
数组参数为引用传递(数组元素值会改变)，
但数组的指针为复制的.
函数声明可以 void fun(int []) 或 void fun(int 数组名[]) 或 void fun(int*)均可.
函数定义时必须有形参数组名，参数类型[]或*可以不和声明相对应.
函数声明和定义时，有无数组长度均可；实际上，数组名[]和*指针名编译器一律当成一个指针参数，并且不检查数组长度.因而，函数声明、定义的数组长度可以随意填写，与实际的数组长度不符也可以！也可省略不写.
该函数的一般调用形式：fun(数组名) 
实参数组名不用加&，也不能写成a[3]!本义想传入指定的长度数组，疏不知此时传入的是数组的某一个元素！程序运行崩溃.
81.C++变量初始化可以写为int a(64),而
C语言只能采用赋值初始化a=64,因为C++增加了类和对象，基本类型也有构造函数.
80..c结尾的文件启用C语言编译器，
若该文件内容为C++代码超出内容报错
.cpp结尾的文件启用C++编译器.
若该文件内容是C语言代码给出警告.
两者编译器与后缀名不匹配给出警告.
(可能自动切换了编译器，DevC++环境下)
79.C语言默认不支持bool，C++完全支持
对于C99以上，可采用以下方式支持：
1._Bool仅支持bool类型定义，但不能识别true和false关键字，只能用int赋值.
2.typedef int bool;或#define bool int
#define true 1
#define false 0
3.终极解决方案
直接包含头文件#include<stdbool.h>
取得完全支持(bool、true、false).
78.char a1=0 和char a2='0'是完全不同，前者将0转换为对应ASCII码的字符(不是0字符)赋值给a，后者直接将字符0赋值给a
注：if(a1)为假，if(a2)为真 (∵'0'为48)
77.多个else if和多个if语句前者效率高，因为前者只要一个满足条件，后续就不会判断；后者所有条件都会执行判断，效率下降.
76.为什么要养成定义变量初始化的习惯，
即使初始化的值0不是自己想要的？
因为未初始化的值是被用过内存空间遗留下来的垃圾值，它是随机的，这会拾你的程序运行正确与否有了很大的不确定性，这是程序编译的大忌：这会为你的程序报错排查带来很大难度.也许系统在将来很长一段时间都不会使用这个内存空间，这个垃圾随机值就在你调试阶段"固定下来"，程序看起来一切正常.直到有一天的到来，系统终于使用了这块内存，一个浩大的工程项目
随之崩塌……
你永远不会发现这个微小的沙粒.
75.NULL代表系统不会使用的区域，它永远不会和变量、对象的地址相同.通常相等0.
74.C语言for(int i; ;)小括号内定义变量写法
错误！新标准C99也不支持！——实测可以.
C++和Java允许这样的写法.
73.指针易错点：
指针作为函数参数传递时是原指针的拷贝！就如同普通变量作为函数参数时也是原值的拷贝；后者可以使用指针来避免拷贝，而前者可以使用二级指针来避免拷贝。
72.函数局部变量仅对本函数有效，
调用的函数无法使用此变量.
另外，C语言不允许函数内定义函数.
71.变量定义声明在同一位置有利于避免重复定义，位置东拉西扯难以查找已定义变量
70.可视化程序设计：
1)插字符光标X位置值从0开始，
指代后面的字符，代表当前位置实际长度；
2)文本每行必须预留一个字符存'\0'
3)从当前光标位置输入一个字符，即
后面一个字符位置后移，新字符取代它，
且光标后移，仍指代之前的字符.
69.清空缓冲区的方法：
1)fflush(stdin);  //头文件<stdio.h>
仅部分编译器支持，移植性差.
2)getchar()  //只清空一个字符，常用于
                    //清除scanf末端的回车符
3)while(getchar()!='\n'){}//万能清空
4)int temp;  //EOF为-1;ASCII码0～255
  while((temp=getchar())!='\n' && 
    temp!=EOF)) ; //输入+文件读取清空
当缓冲区为空时，不要自作聪明使用后三种方法，否则程序要求你键入才继续运行.
68.输出函数区别总结：
puts(数组名)输出字符串并自动回车；
printf("%s",数组名)输出字符串不回车.
注意：scanf()可以同时残留多个和多种符号，这就是为什么法三而不是法二是万能的.
67.输入函数区别总结：
scanf("%s",数组名/指针，无&)：输入字符串不能含空格和制表符，空格、制表符、回车作为一次有效输入后的终止，并且它们都保留在缓冲区，下次输入为数字或字符串将被忽略清除，但输入为字符时将被接受而产生输入错误.
gets()(禁止使用)：输入字符串可以含空格和制表符，且位于输入的开头算有效输入作为字符串的一部分，只有回车符作为输入终止，并清除，不会保留在缓冲区.即使无有效输入(直接回车)，仍然是会结束输入，此时为空字符串("\0").
C11以上新增gets_s()安全版本，
而fgets(字符名，字符数n,参数3)C语言新旧标准都存在，它主要用于读取文件，也可以用来键盘输入，参数3改为stdin,最多能读取n-1个字符，第n个填充'\0'；不足之处是若输入小于n-1个字符，将读取回车符，需要手动去除.缺点2:无论输入什么类型，缓冲区残留回车键均不会忽略导致提前结束输入.

a[0]=getchar()读取缓冲区的一个字符，缓冲区为空则会等待键盘键入，而非读取但NULL!赋值等式左边必须是一个数组元素，不能是数组名，getchar()可以作为左值(如getchar()!='\n')
与上述函数在<stdio.h>不同，下面两个函数头文件在<conio.h>中：
getch()(不回显，常用于密码输入、程序调试性中断)，直接从键盘接受一个字符，无论缓冲区是否存在字符，都要求键盘键入，缓冲区的字符没有改变仍然存在；
getche()与上个函数唯一区别是会显示输入的字符.
66.NULL和0都可以作为指针函数的返回值，但其他数字不行.
65.指针函数(返回值为指针)和引用函数(返回值为引用)必须用new动态创建，否则函数结束对象销毁，指针或引用的指向丢失而导致输出乱码或程序崩溃(注：编译不报错)
64.构造函数大括号｛｝中或函数参数和类数据成员同名，会屏蔽成员，初始化列表不会.
如：a::a(int i):n(i){  }   //正确
a::a(int i) {i = i;}  //错误，类成员i被屏蔽，参数i自己给自己赋值，可以通过this调用.
但构造函数尽量不使用this指针，最好改名.
63.int *p = new int();
delete p(动态创建)删除的不是指针本身！而是所指的内存空间.若此时未写p = NULL则p成为野指针.
p会在函数作用域结束时删除.
62.数组a[i++]先赋值在运算(+1)
60.指针初始化写法：
1)char *c = b(b为指针)
2)char *c = &b(b为变量)
3)先定义后初始化
   char *c; c = b或&b
以上三种写法不能用于new指针！
错误写法:
1)char *c = 'a'; (没有&'a'这种写法)
2)char *c; 
    *c = 'a';   (new指针时正确)
第二种写法严重错误！会导致编译语法检查不报错，运行时程序崩溃无响应.
原因在于指针c的指向地址都未确定，
如何能给它所指内容赋值？
但是new动态创建的指针
只有第二种写法正确！
因为：动态内存 char *c = new char();
      有括号默认为空字符，无括号为不定值；
      可见new会返回堆的地址，该语句在
      已经给指针c初始化了.那么上述第二种       
      写法*c = 'a'正确；相反，一般的初始化  
      语句c = b或&b错误，可怕的是语法上正   
      确编译不报错，但是此时指针指向已经
      改变、堆空间丢失，造成内存泄露！
59.构造函数的初始化列表无先后顺序，故子类构造函数初始化列表中父类构造函数可以靠后.如果该列表没有显示调用父类构造函数，系统会自动调用父类的无参数构造函数.
注：若已存在手写构造函数，系统不再提供默认无参数构造函数；
只能在初始化列表中显式调用父类构造函数，不能在大括号｛｝内调用.
58.子类的构造函数的初始化列表不能初始化继承的父类成员(无论是公有还是保护属性)，但可以在{}内通过赋值初始化.
57.使用string除了包头<string>头文件之外
还需写上using namespace std,
否则应写为std::string!
56..exe编译器下运行会自动停留黑窗口，
直接运行无输入程序则会一闪而过，需要
添加system("pause")语句以停留窗口
55.for(表达式1;表达式2；表达式3)
表达式2不写默认为真，无限循环；
三个表达式可以都不写，但两个分号必须有
54.setw()只对下一个输出点有效，
故cout<<left<<setw()<<Date
会造成 年与日月分隔,显示不连续.
53.析取>>和插入<<只能友元函数重载
52.头文件重大误区修正：
1)#ifndef可以防止头文件被重复包含——防止的是被同一个源文件(.c)包含，不同源文件仍然可以包含同一个头文件.
2)因此头文件只能写声明:
如果头文件中含有定义，即使写了ifndef,若该头文件被同一项目的不同源文件包含，编译最后将不同源文件连接在一起，仍然会产生重复定义的报错；
3)在头文件中，友元函数、类的静态函数或者类的成员函数的实现若写在类外(大括号外面)，会产生重复定义；函数实现写在类内则没有此问题，因为此时实现在类内视为类的定义，不分配内存，也就不属于真正定义，等同于声明.在类外写成inline内联函数也可，因为只是将代码复制到声明位置.
4)友元函数的声明不是函数声明，因为它只是声明了对类成员的访问权限，该友元函数必须在类外进行额外声明，否则即使引用了该头文件，仍会报错未定义！(万恶之源)
51.C语言中空指针：NULL  是大写
     Java语言中：     null  是小写
50.Tab键和空格键不能混用
(不同编辑器和系统Tab键代表宽度不一样，混用造成上下行代码缩进不一样，不对齐)
否则即使代码看起来对齐，一运行就显示错乱，除非启用"Tab键转换为空格键"功能则可以消除代码显示和输出显示不一致的现象(新键入的Tab才生效)，因为此时Tab键不是输入'\t'字符,而是空格；推荐使用空格键，或者开启此功能使用Tab键，缺点是不能通过修改Tab键值批量改变缩进量，因为此时Tab键输入的是空格.
Dev C++启用此功能——
取消勾选"使用Tab字符".
49.引用定义初始化：
数据类型&引用名 = 变量名，至此引用名成了这个变量的别名，和变量名都指代这个变量.引用在定义时必须初始化，并不能再改变这个引用名指向.
引用在定义时需要加&,使用时不用添加&,
否则表示取地址.
18.引用&写法：int&  i； int  &i； int&i
35.引用是对象的别名，实际就是对象本身
形参&b是b别名(形参时可同名)，它就是b；
形参b虽和b同名，但它是b的拷贝.
三种写法都对，是否空格分开无区别
48.友元函数和静态函数可以在类中定义，
(可能是编译器支持，也可能是标准.)
并且静态只能调用类的静态成员.
而类的静态数据成员(指变量)只能在类外初始化，因而静态数据成员的初始化不应该写在头文件而避免产生重复定义.
类的静态成员(包括变量和函数)可以 类名::成员，且即使private、protected也可以直接调用(注意静态私有对继承类不可见)；
同时，由于静态成员属于类，不仅对于所有对象共有，而且对于父类和子类也是公用！
所以静态成员还可以写成：
父类名：：成员
子类名：：成员
父类对象.(父/子)类名：：成员
子类对象.(父/子)类名：：成员
非静态成员只能写成对象.成员
47.函数参数为引用(int &),声明与定义不一致时(缺少&),会报错"non-static data member initializers only available……"
46.任何指针(b)都可以写成b[3],只要将数组名赋值给该指针.(b[]都会自动转化为*(b+3).两者等价，*(b+3)写法效率高.)
string除外，因为它的字符串名代表整个字符串，不会像数组名一样转换为首元素指针，不同于用字符数组表示字符串.所以：
任意字符串指针(string*)在用(&字符串名)赋值后不能写成s[2]或*(b+2),只能整体*b输出；字符串名本身输出单个字符只能写成a[2],不能写为*(a+1)∵字符串名不是指针.
45.数组名(例如int a[])除了(1.sizeof(a) 2.&a)两种情况下会是本义(指向数组)之外,其余都会默认转换为指向数组首元素的指针，为指针常量，其值为首元素地址.所以
a是指向首元素的指针，类型是int*
&a是指向数组的指针，类型是
int (*数组名) []--数组指针；
指针数组表示为int  *数组名[]，优先级()高于[]高于*.
a+1指向下一个元素，&a+1指向下一个数组
注：
数组地址与数组首元素地址不是同一个概念
虽然两者值相等；cout<<指针会输出指针的值，即它所存放的地址；数组名为指针常量，不同于指针变量，不能再为其赋值.
44.常量指针(不是常指针)：
const 数据类型(可以前后调换)* 指针变量
指向可以改变，不能修改指向的值.
(常量指针可以指向变量，不一定要是常量，仅表示不能通过该指针修改所指内容.)
指针常量(常指针)：
数据类型 * const 指针变量名
指向不能改，可以修改指向的内容.
(巧记：const修饰指针变量)
43.\a是响铃符，可以让win10发出警告音.
42.关于字符知识总结：
{
1.整型数字本质就是十进制数(可以看成十进制的ASCII码值)；它对应的字符不等于数字字符，数字字符对应的十进制ascii值也不是该整型数字；
例如，
char = int会将整型数字转换成对应的十进制ASCII码的字符数字(不等于该整型数字)，
int = char会将字符数字转换成对应的十进制ASCII码值数字(不等于该数字字符).
结论是
整型数字和数字字符两者相互独立，
并不是一一对应关系.

要想将整型数字和数字字符转换成一一对应，则按下面写法：
int = char -'0'  
char = int + '0'
相互转化本质都是八进制ascii码的加减运算
2.标准ASCII码最高位为0，共128个，数值范围由0-127，超出该范围显示为乱码.
所有的ascii码都能由
\八进制(十进制数开头没必要加0，默认当做八进制数.若开头加0导致\后面超过3位数，则出错造成只截取保留最后一位数)
或者
\十六进制(由于存在反斜杠，前缀由0x变为  x，写成0x会出错只保留最后一位数，同时数字开头没必要加0)
进行转义，在以二进制形式存放.
(\a响铃符、\n换行符、\r回车符等属于第三种在C语言内使用"\英文字母"的某些字符的快捷表示方法，而不用记住ascii码值)
故int转char先变八进制后才能加\，不能直接\十进制.
例如：换行符(\n)十进制ASCII码是10，\10不是换行符，\12才是.
3.char强制转化(int)：输出十进制ascii值，
不是八进制.
   int强制转化(char)：不是直接加\转义，
而是先将十进制转八进制.
4.\n与\r:
\n换行符，本义是切换到下一行，不一定是行首；
\r回车符，本义是回到本行行首；
win下两者是本义，行末\r\n,打开Linux/Mos的文件会变成只有一行；
Linu下行末\n,改为换行且回到行首，
Mos下行末\r,改为回到行首且切换下一行，
两者打开Win文件行末会出现^M符号.
常用十进制ascii：\t(制表符)
\n(换行)：10  \r(回车；回到本行行首)：13
  (空格，无转义符号)：32   
\0(null；字符串结束符)：0
5.数字前后缀  ：
0b二进制(B)  十进制(D) 0x十六进制(H)
注：前缀用于C语言，后缀用于汇编语言；
前缀由数字0和不区分大小写的字母组成；
C语言标准中没有二进制的表示(定义、输入输出)，自然没有前缀一说，有的编译器支持该非标准前缀0b；
十进制没有前缀，不写后缀默认为十进制.
6.位、字节、字：
位(bit，b，比特)是计算机最小的储存单位；
字节(Byte,B)，1个字母等于1字节等于8位；
字：1个汉字等于2字节等于16位；
(另外还有双字，1个双字等于2个字，32位)
注：大小写的b代表的简写不同；  1个ASCII码用8位二进制数表示，等于1字节；
Unicode码包含ASCII码，UTF-4码一个字符/汉字等于4个字节等于1个字，32位.
}
41.\0表示字符结束符，空格是ascii是32(\040)；单引号'\0'显示上和空格一样，双引号"\0"占空间却不显示，即输出单字符显示同空格(因为无法显示但要占一个字符空间)，而输出字符串不会显示；
因此输出\0时%d会显示空格，%s则不显示.
字符串没有\0结尾可能会输出乱码.
41.1""和NULL含义一样，
但前者对应字符串，后者对应字符；
故字符串初始化用""，字符初始化用NULL,
两者不能混用，''不能用于初始化字符.
40.在类中引用或指向另一个类，需要前置类声明；而在类中声明一个友元类不需要额外前置类声明.
注：前置类的声明是一个不完全的类型，因此只能定义类的指针或引用，不能调用具体它的成员函数，除非前置类的定义.
39.函数名了变量名不能在同一作用域重名，
即使：函数()；fun(fun){}属于不同作用域
38.宏名本身允许重复，
     头文件不允许宏名重复，重复就不会包含
37.报错：...is private.
使用友元函数仍然保存，可能是定义与声明参数类型不一致，定义int&,声明却为int.
(报错与原因不沾边，莫名其妙，记一下)
36.当你报错修改后，未保存，文件名星号※仍存在，修改未生效.
有时候是Dev-C++出bug,关闭重启.
34.若仅声明了类class A，则不能定义类，只能定义类的指针A *a，因为类未定义编译器无法知道其大小.(定义需要分配空间)
且不能定义类的成员函数(类都没定义怎知)
33.函数声明时参数名字会被忽略，
因此声明时参数名字可以随意或省略不写，
只会以函数定义时的形参名字为准.
32.成员函数(友元不是)之所以写成：
     成员 等价于 (*this).成员，
两种写法都正确，因为任何对类成员的直接访问都看成是this指针的隐形使用.
友元函数不是类的成员函数，所以没有this指针，必须写成：对象名.成员
(类成员包括数据成员和成员函数)
31.类初始化易错点：
在类外初始化列表  类名：：类名()：变量(赋值){}
       1.忘记“类名：：”
       2.忘记第二个类名跟着一个()
      (构造函数也是函数，有参数括号)
30.定义一个局部变量会屏蔽全局变量，
若要在该局部作用域内引用全局变量，
则要加作用域解析运算符::
例如，   x = 5;(局部变量赋值)
          ::x = 6;(全局变量赋值)
同理，
子类和父类成员可以同名，屏蔽父类，
a.b     //调用子类同名成员b
a.c::b  //调用父类c的同名成员b
(对于a.b，若a中没有定义b,系统就近调用父类的b则此时以上两种写法等同)
形参不能与函数内定义的变量同名：
因为会屏蔽形参而导致函数无法使用，编译无法通过！
29.    全局变量对所有源文件可见；
static全局变量限定为仅对本源文件可见；
         局部变量(auto)生存周期为{}内；
static局部变量生存周期为整个程序运行期间，所以函数结束时值会保留不会消失，但和全局变量唯一的区别是仅对该函数可见
静态局部变量的使用场合：
多次调用同一个函数，而期望该函数的变量调用结束之后的值保留，此时就可以使用静态局部变量，因为该变量会在程序运行期间都会存在，并且只会初始化一次！
备注：
全局变量会自动初始化为0，局部静态变量不会自动初始化，但默认值为0，局部非静态变量未初始化为不定值！
28.
函数类型前面加static变成了静态函数，或称为内部函数，它就变成了仅对本文件可见
27.当有返回值的函数没写return，编译通过但运行可能会出错，返回值为不定值(Dev- C++好像默认return 1)
-----------------------
C语言零碎知识点：
1，++i前后置在赋值表达式中效果不同，说      
   明赋值等号、判断语句是"运算"
2，main最新标准写法：
    int(旧版代码可以不写)
    main(1，参数类型|2，void)
   仅这两种写法，
   主函数返回值void类型的写法不正确
3.字符型1字节；整型4字节；实型4字节；
   双精度型8字节
4.赋值表达式优先级高于逗号表达式；
5.文件分法：
   介质–普通文件.设备文件
   读写–顺序读写文件.随机读写文件
   储存–文本.二进制
6.\0的ASCII码值为0
7.for语句小括号内一个分号可以执行多个语句
8.C与C++都没有幂运算符，∧是按位异或
9.异或——不同为1，相同为0
10.逗号表达式优先级最低，从左到右，
     取最右边表达式的值
11.强制转换不会改变变量自身类型
12.C语言空语句为 ;(一个分号)，
     Python空语句为 pass
    ｛无内容｝为空函数/空语句块.
13.函数内已经定义一变量；复合语句内
   (if for等)可以再次定义同名变量，两者相
   互独立，语句内优先复合变量，其作用域
   仅在复合语句内(即不会报错重复定义)
14.switch语句如果没有break跳出，
     default会按顺序执行，然后跳出循环
15.函数声明：类型  函数名(参数类型)
    参数名字可以省略；
16.strcpy(1 , 2) 把2复制给1；
    strcmp() 大于整数，小于负数，0等于
17.对文件读入编辑后，
    必须执行fclose重新保存，
    才可进行文件读出操作(fgets等)
18."m"为字符串，带"\0"；‘m’为字符，
     strcat连接带"\0"字符串
19.a[][][]中a[]不是元素而是0行分数组/地   
    址，因为a是多维数组
20.a[5]中的5在定义时是指长度；
 定义后指具体5号元素，a[5]＝2(元素赋值)
21.1/3=0切记！1.0/3或者1/3.0才保留小数
22.二维数组a[][]中
     a为0行分数组地址，二维数组名；
     *a为0行0列数组地址，0行分数组名；
     **a为0行0列数组元素.
     一维数组a[]中
     a为0列数组地址，一维数组名；
     *a为0列数组元素
23.数组不可以相互赋值，同类型指针可以
7.函数指针(*f)()和f()两种调用方式均可，
   都指向原函数；历史遗留问题
9.结构体struct a(定义结构体变量时)，
   前缀struct必须写(实测.C文件用C编译
   器确实必须写)；
  (C++可以省略，和C语言不同)
补充：
 1.C语言不允许在定义结构体时，非静态成员直接初始化，只能在用该结构体定义变量时"struct 结构体名 变量名={}"初始化；
C++11以上允许.
2.结构体可以定义在全局区域，
也可以在函数内定义.
3.typedef struct 结构体名(可以无名)
{
      结构体定义内容
}新名；
视为typedef struct (结构体名) 新名，
忽略定义内容，故不会产生重复定义问题.
第3条typedef无名结构体限制：
不能在定义完成后使用"typedef struct 新名"语句赋予新名，只能typedef在其定义时与之连体创建新名，并且其成员当中不能存在指向自身的指针成员(例如*next)，
因为：typedef struct 新名
和      struct* next
没有这样的写法！struct只是一个标识符，
不能作为结构体名(定义时可以没有名字).
有名结构体不存在这样的问题限制.
24.变量名和函数名不能相同。
 局部变量名与全局变量名或函数名相同，则 
 在该局部不能使用相应的全局变量或函数
25.函数内不能再定义函数，只允许声明调用
26.定义无参数函数时f(void)，
     调用是去掉void, f()
27.如果函数为void类型，return；后面不接任何值，可用于跳出循环且终止函数
28.a=a++写法不规范，
不同编译器结果不同，可能导致未知错误；
编译过程：先赋值，放在内存1；再将a++结果放在内存2，a输出取用内存1；
28.当你检查所有代码无误后，
极有可能是头文件部分产生的报错



C++零碎知识点：
1.浮点位数为整数加小数位数，小数点不算
2.typedef的妙用：
   char*可以用新名字便捷定义指针；
   double 新名字  跨平台移植替换double               
   而不用改变代码内容
3.函数的重载只要参数类型或者个数不同，
   函数类型可以相同
4.内联函数(inline)、寄存器变量(register)
   均是用空间换取提高程序运行效率
5.局部动态变量默认自动补上auto,
   如果手动写auto会产生重复定义而报错
6.
[图片 205.jpg]

10.指针类型p：
     要么(*p).成员，要么p->成员；
    非指针类型p：
     只有p.成员，->操作对象只能是指针.
     ( (&p)->成员也行,不过没必要)
12.类中const函数修改数据成员会报错；  
    static静态成员除外，可以修改
13.char型1字节；字符串型string 4字节
14.static静态成员函数因为是公用，参数需要具体对象.成员，静态数据成员(公用)除外
15.类中数据和函数未说明默认私有
16.友元函数：friend 类型 函数(类名&对象)
 在类外定义： 类型 (不需要类名：：)函数名
                     (类名 &对象)
 友元函数调用：(不需要对象.)函数名(对象)
17.编写项目时，确认无误却编译报错，
保存重启Dev C++,再次编译成功
19.cin>>删除结束符(回车，空格，制表符)；
    cin.getline()会删除缓冲区中结束符
    cin.get()不会删除缓冲区中结束符
(get有1/2/3个参数的用法，1个时为字符：
  a=cin.get() 或者 cin.get(a);
  getline有2/3个参数用法，没有1个参数)
书上关于get、getline表述：
      "读取但不保存"说得就是删除，
      "不读取也不保存"指保留在缓冲区，
      读取与否都会遇到结束符停止输入.
cin补充：
在未遇到有效输入前，忽略并删除缓冲区中的任意数量分隔符(空格、制表符)，遇到回车并已经有效输入已经达到需求会结束输入并清除回车.
20.if/while的小括号()内：
可以定义变量且赋值，表达式返回值为赋值后变量的值(即if(i=0)不执行，而if(i==0)执行)；定义时比较>=等操作优先于赋值=，且不能加二级括号定义变量，非定义可以加；
if()小括号内定义的变量对else语句存在，所以else不能再定义同名变量，除非加{}；
if()-else属于同一作用域，if()-else if()
属于嵌套调用作用域不同，故后者的else语句内或if()内可以再定义同名变量；
if/while的{}大括号内:
可以定义变量，不会产生重复定义的错误，因为循环复合语句内每执行一次循环结束，语句内定义的变量就会消失，下一次循环重新定义；if(){}在大括号中定义变量对else语句不存在，所以else可以定义同名变量.
21.#ifndef  宏名1    (如果宏名未定义，则        
    #define 宏名2  定义该宏名，并执行编译
    #endif              与endif之间的代码)
    宏名1和宏名2可以任意命名，但必须相同
    且在头文件中是唯一的
    作用：防止同一个头文件被重复包含
命名通用规则：
    宏名一般开头下划线，大写，点变下划线
22.报错
  jump to case label [-fpermissive]:
原因：使用switch语句case后定义新变量，若跳转未执行该case语句，造成"存在却未定义"的怪现象，因为此时作用域在switch{}大括号中；
解决方案：1.在case后面语句块再加一个{}来限定定义的新变量的作用域
2.不在switch-case语句内定义新变量
23.类的定义属于声明性质，但仍不允许类重复定义(可以重复声明).类的定义不同于一般的函数、变量定义，不会为类分配内存.
23.1变量的定义不等同于与初始化，全局变量、静态全局变量、静态局部变量未初始化默认为0，局部变量(auto；非静态)未初始化为随机不定值.
赋值是初始化实现的一种方式，例如：
int a定义但未初始化，随机值，
int a(3)为直接初始化，int a=3为赋值初始化，效率差不多，但类的数据成员通过构造函数直接初始化，比构造函数的赋值初始化效率高
24.C++旧代码中数据成员(变量)初始化不能在定义时就赋值；C++11以后，可以在定义时直接=赋值；构造函数的初始化会覆盖定义时的赋值，构造函数的赋值会覆盖构造函数的初始化，三者可以同时使用.
25.类的友元函数必须定义一个这个类的指针形参(指向对象)或引用形参来访问该类的私有或保护成员，因为它们属于某一个对象而不是类.  (或者没有形参也可以，但是必须在该友元函数内定义实例化一个对象，一般很少用这种做法)
26.string作为C++补充的"基本数据类型"，可以直接=赋值，==比较相等，不必像C语言数组使用strcpy,strcmp.
-------------
C++语言bug点：
40.bug点：
1.
声明 friend class A为class B的友元类，
此时A中的友元函数不能调用B私有成员，
因为友元函数不属于A类！
2.*p++  后置++优先级比*高，但是！因为后置，先运算*p再p++(地址后移)；
*++p  前置++与*同级，先++p后*p.
前一种情况运算顺序恰好与优先级相反！
注：while(*p++)先用*p判断真假，再p++.
3.C/C++编译通过，程序运行时崩溃无响应，多是内存管理问题.应当检查数组是否越界、动态分配是否成功、空间分配足够,还有结构体指针为空，却访问其成员.
4.字符串函数strlen()参数不能传入NULL
空指针！编译不报错，因为有时传入参数只有运行时才知道;但会导致程序运行时崩溃严重后果！
每次调用strlen()时应该参数作非空检查.

C++语言设计思考：
(1)既然C++提供了容器下标越界检验手段，为什么不默认呢？(我知道是出于效率)，反正最后程序员还是要手动搭建检测；或者编译器进行可拆除是检测呢？––猜测：程序员能更合理判断有无需要进行越界的必要，编译器做不到像人一样智能生成的可拆卸检测措施.
(2)为什么很多请求由编译器，如inline内联函数、shrink_to_fit()，那程序员手动写这些请求有什么意义？
––不要去知乎所谓查阅的标准答案，留给自己不断地思考，等待自己学习更多知识和拥有更多实践经验后恍然大悟的一天.
这才是学习的动力和乐趣：不断解开自己以前的疑惑.

重大学习进展：
IDE(集成开发环境)会智能提示所有重载函数、对象成员函数版本，包含形参和返回值.因此：
学习新知无须再费心思去记忆各个函数版本的参数类型和个数了，再也不怕记混了，也不用去查询接口手册了.
你只须把精力放在思考：
从宏观上，
每个函数实现的功能是什么、调用场景有哪些、使用有哪些注意/易错点.

Python编程：
注意-实例属性的构造器__init__(self)
         的下划线是两个空格的长度
         '｛｝'.format()是点，不是逗号


零碎知识点：
1.Python冒号：之后缩进4个空格
2.

已看完：(装饰器)
Python教程：
按顺序学：
1.2.7-赋值运算符及内存分析 已完成
跳学(已完成)：

1.18.6-1.18.8正则表达式-贪婪模式全部完
1.15.7 魔术方法1-3
1.15.2-1.15.5
1.14.5-1.15.1 类方法
1.14.0回顾总结
1.13.5-8
1.13.4 图书管理系统 
1.13.1-3
变量作用域先不看
1.11.8 多层装饰器
1.11.9 装饰器的应用
1.11.7装饰器
1.11.6闭包：计数器
1.11.1/2/3/4/5 闭包
1.10.7全局和局部变量1、2
1.10.6函数嵌套调用1、2
1.10.5函数返回值
1.10.4参数类型知识小结
1.10.3关键字可变参数
1.9.5类型转换
1.8.2拆包和装包
1.7.5冒泡排序
1.7.4王者荣耀购买武器
1.5.6判断数字
1.5.5编码，判断字符串开头结尾
已看完
1.3.3-1.3.5 进制转换，位运算，三目运算符