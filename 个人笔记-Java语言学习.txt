Java零碎知识点：

128.Content-Disposition如果响应头未设置该字段，默认是inline，即浏览器会直接在页面打开文本、播放音视频等文件; 如果需要下载文件，需要指定为attachment(附件).
127.实测Pattern.UNICODE_CASE忽略字母大小写无效，只有Pattern.CASE_INSENTIVE才生效.
前者可能用于其它外语的大小写.
126.实测正则表达式的反向引用只能引用前面位置的捕获组()，因为位于后面的捕获组此时还没运行没有结果放入内存.
坑:  反向引用需要写成双反斜杠(\\1)，否则将把1转义成字符，造成莫名其妙的匹配失败，难以发现; 编译器不报错！
[ ]中不能使用反向引用，否则报错.
125.正则表达式零长度匹配需要满足两个条件：
1)存在于?或*号两种允许长度为0的两种匹配.
a* a? (aa)*会产生零长度匹配，因为它们允许长度为零;  aa*不会产生零长度匹配，因为前面有一个a占位，所以要求长度至少为1.
2)只要出现非目标字符，在这些字符前都会出现零长度匹配,注意字符串结尾处也算.(索引从0开始).如果出现目标字符，则不会产生零长度匹配.
124.Interger.MAX_VALUE等于2GB-1
123.SpringMVC中同时对请求总大小和单文件大小做了限制，在使用StandardMultipartResolver组件时分别抛出请求异常MulitpartExeption，内包含MaxUploadSizeExceededException，可通过getCase()获得) 和单文件异常(MaxUploadSizeExceededException).
如果使用的是CommonsMultipartResolver的Apache组件，一律是MaxUploadSizeExceededException，但可由内部原因FileSizeLimitExceededExeption区分.
122.如果要对一段代码进行重构，请重新书写，不要在原来的代码上修修补补！且只参考原来代码的大体思路，避免逐行参照，极其容易造成逻辑疏漏！
121.server.context-path和类上的RequestMapping()是给浏览器url请求/重定向用的；而view.prefix和suffix是帮服务器转发自动添加文件路径用的，构成一个绝对路径(页面资源根目录是webapp, 代码资源根目录是src/main/java.)
补充：
SpringMVC无@ReponseBody注解情况下直接返回String值代表转发(相当于默认加上"forward:");
当返回值为"redirect:路径"代表重定向，如果没有/开头则为相对路径，相当于同级目录下(去掉当前方法名即当前所处目录)，如果/开头，代表使用绝对路径，注意SpringMVC会自动添加server.context-path，帮助浏览器完成重定向/或者说解耦合. 注意人为输入url地址进行访问时需要自己手动输入server.context-path.
120.JSP中的js代码使用//或/*  */注释无效！！
JSP编译器只会识别<%--   --%>.(巨坑..)
119.mysql一条记录有外键且用外部引用情况下不能直接删除.
方法1: 先删除所有引用此外键的其它表的记录，再删除此记录.
方法2: 使用set foreign_key_checks=0临时将外键约束关闭，再进行删除操作，之后=1恢复.
118. //rep.reset(); //清空响应体,不会提交到socket输出流,续传信息SC_PARTIAL_CONTENT被清除  --文件续传损坏的根源!
117.session设置最大非活跃时间是指向服务器发送请求，而不是单纯地操作滑动网页.
Cookie默认关闭浏览器失效，只要手动setMaxAge()，关闭浏览器便不会失效.相应地，session.setMaxInactiveInterval()也要与之对应.
116.
(2)两者都是只要线程不释放对象锁，其它线程无法进入此区域，也无法调用其它使用相同对象的synchronized方法/代码块.
(1)synchronized作用在方法上，如果是实例获取this对象，如果是静态方法则使用的是.class的是对象；
synchronized作用在代码块中，使用的是(obj)括号中指定的对象，称为客户端锁定. 值得注意的是:如果改变了obj的引用指向，将导致synchronized()失效，多个线程可以同时进入此区域！注意如果obj不能为null，否则将抛出空指针异常.
(补充：亲测改变obj对象内部、改变对象真实地址——调用ensureCapacity()使之重新分配内存块均不会使synchronized()失效；而new一个相同内容会使其失效. 可见，synchronized()并不是使用hashCode()、equal()方法判断，也不是使用真实地址判断，而是根据引用指向判断. 总而言之，只要不改变obj的引用指向，都不会导致synchronized()失效.)
根据以上实操，猜想：
核心卷I中关于Vector.set()等更改方法的相关描述是错误的！

*正确说法应该是：
在使用客户端锁定时，obj最好是final变量;或者需要保证：obj的引用指向在临界区域内不会被自己修改或者在外部非同步区域不会被其它线程修改.
(3)接口声明中不能使用synchronzied关键字给接口方法作限制.
115.为什么notify()可能会导致死锁？
因为前者只唤醒了一个休眠线程，一旦它发现不满足运行条件再次调用wait()，整个系统死锁.
注意区别休眠中线程等待的是notify/notifyAll()信号，而不是wait()释放的对象锁！
114.MyBatis的Mapper接口不支持重载方法.
113.关于ipconfig的多个ip地址:
"以太网适配器"一般是指网线连接的物理网卡，
"以太网(虚拟网络VWare Network)适配器"一般是指虚拟网卡，不能对外上网，只能用于虚拟机和宿主系统之间内部连接传输数据；
"无线局域网适配器"一般是指wifi无线网卡，
剩下两者可以对外上网.
三种IP都是本机地址，取决于别人如何用你的IP地址来联系你，这就要看从哪个网络或网卡来联系你了，一般来说是通过wifi局域网.
112.异常堆栈信息的正确阅读:
(1)同一个case by的at最上面一行是异常new创建发生的地方,最后一行是最外层调用的地方. 也就是说,异常栈由内层层向外层沿着调用链向外/顶层传递, 对应at从上到下顺序.
(2)一个异常可能存在多个cased by, 是通过包装异常(initCase)产生的:从上到下,上面行的cased by异常是由于下面行cased by异常引起的. 下面异常是更深层的异常.
下面行的case by仅列出不用行的堆栈信息, 和上面case by一样的堆栈信息用... more省略表示, 所以不同的cased by按由下到上、同一个cased by的at按由上到下顺序拼接在一起,可以组成一个完整的由最内层到最外层的异常堆栈信息.
(3)Suppress:是被抑制的异常(通常是close等方法), 由于一个只能initCase一次异常, 且被抑制的异常一般是在finally块中新产生的, 两者不存在因果关系. finally块中抛出异常导致catch()中的异常无法被吞(抑制), 通常做法是对catch异常调用addSuppressed()将finally异常添加到其中,毕竟catch才是主要的异常, 也不会丢失信息.
(4)理论上所有的异常堆栈都可以追溯到Thread.run()或main()方法(最外/顶层), 或者说所有的函数调用都从这两处发起.

111.关于线程池：
(1)线程异常"消失被吞"问题：
submit()被设计成将所有子线程运行结果存入outcome成员变量，包括异常. 所以只能通过调用get()方法才能获得异常信息. (设计者认为既然你调用了submit，必然会有获得运行结果的需求). 而execute()则会直接抛出异常，不存在"消失被吞"问题. 对于没有返回结果的任务，请直接使用使用execute方法，无视submit()只接受一个参数的重载版本，避免忘记使用get()方法造成异常被吞.
补充：UncaughtExceptionHandler单独捕获器不能捕获submit()子线程抛出的异常，因为它被setException()存入outcome.
 excute()方法异常则可以被单独捕获器捕获.
 默认处理器属于全局，可以捕获所有线程(包括main线程)的异常.
submit()-get()方法获得的异常属于在调用线程(如main线程)抛出，而execute()方法在子线程内完成抛出和捕获，其它线程并不知道也无法捕获.
(2)线程池如何处理抛出异常线程?
<1>对于execute()提交的线程：线程一旦抛出异常, 无论是否设置了异常捕捉器, 线程均会终止. 线程池只对正常结束的线程回收利用；而将抛出异常的线程移出，新建线程添加补充进来. 
(这里就可能存在一个风险：如果用户任务大量的抛出异常，可能会导出线程资源频繁的销毁、创建。因此，需要用户任务应当主动对(检查型)异常进行处理，而不是消极的抛给线程池。)
<2>对于submit()提交的线程：会将抛出的异常存起来，等到调用get()方法时，在当前调用(主)线程抛出，此时不属于线程池内的异常. 所以说submit()是对线程池友好的——不需要对异常线程销毁，可以直接回收. 但是，其抛出的异常如果不捕获，会导致所在的主/调用线程终止运行.
为什么线程池不回收exetue异常线程？
便于走用户设置好的捕获器代码——JVM只有在线程被销毁时才调用捕获器方法.
而submit(单独)捕获器根本捕获不到其异常.
(3)线程自身的处理器和全局的异常处理器：
如果线程自身设置了异常处理器uncaughtExceptionHandler，那么将会使用这个
如果没设置，将会在父线程组中查找第一个重写了uncaughtException的线程组(默认实现null)，然后调用他的uncaughtException方法. 如果父线程组都没有重写，那么使用应用默认的全局异常处理器defaultUncaughtExceptionHandler
如果还是没有设置，直接System.err打印信息.
如果想要设置自己的异常处理器，可以通过对应的setter方法进行设置，如果想要设置全局的可以调用静态方法进行设置 .
也就是说，各异常处理器优先级：
自身单独＞线程组＞全局默认＞错误流.
(默认处理器可以捕获所有线程的异常，包括main线程. 这也就是为什么它优先级比线程组低的原因)
补充：单独捕获器的不同设置方式
对于new Thread()的单个线程, 可以直接通过setUncaughExceuptionHanler()方法设置单独; 但对于线程池, 此方法设置无效!!因为submit()和execute()方法通过DeafultThreadFactory重新创建一个新线程，而默认线程工厂接收形参的是Runnable()接口，并不知道你传入的是已经设置好捕获器的线程，所以此Thread被作为新线程的target成员退化成Runnable接口使用，getUncaughtHandler()方法将被隐藏(因为接口中没有),出现异常时将不被调用.  而此时新线程的单独捕获器为null.
解决方法是自定义线程工厂来替换默认线程工厂，设置新线程的单独捕获器. 但很遗憾地告诉你，这属于画蛇添足行为! 因为线程工厂用于批量创建线程，统一的单独捕获器，不就等同于全局捕获器吗？所以对于线程池，你只需要记住：单独捕获器设置无效，也无需去操心如何设置单独的捕获器，就用全局捕获器.
全局捕获器的设置仍然是调用setDefaultUncau
ghtHandler()静态方法.
(4)《Java高并发程序设计》中的线程run()方法包装器现在看来没必要:第一点,通过new Exception()抛异常会产生较大的性能开销---这主要用于获得线程池提交/调用者信息, 而通过自定义线程池名字, 即可从正常的抛出堆栈中获得调用线程池的名字. 第二点, 主动try-catch和不写try-catch效果是一样的! 属于画蛇添足行为. 原因--对于检查型异常, run()方法强制要求try-catch, 那何必在通过包装器在重复try-catch一遍呢?对于非检查型异常,即使单独异常捕捉器、全局捕捉器、线程组捕捉器全部均未设置为null, 最后一道防线JVM默认通过System.err将错误堆栈输出. 

109.(1)RuntimeException及其子类不需要异常声明，与之并列的IOException和所有父类(Exception、Throwable)都需要检查.
(Error及其子类不需要检查).
(2)函数可以声明多余的异常类型，而函数体中可以没有这些异常的抛出.
106.我如果获取了目标的session id，不是照样可以伪造身份吗？你把session信息存储在服务端又安全在哪里呢？
刚刚查了一下，相关的资料，得出了确实两种方法都半斤八两，安全性差不多的结论，以下摘抄自某文章
（没错，其实HTTP本身就不安全，只要是存在cookie中的数据都可以获取到并加以利用，
但是session的安全性也是相对的，由于数据存储在数据库中，就算sessionid被获取利用，
但是session中的数据并不会被恶意程序获取，这一点相对cookie来说就安全了一些；） 

记一下来自我自己的分析：
经常存在session -id还存储在浏览器，但是session信息已经过期的情况，此时进行登录，
它会依照你当前的session -id创建session文件。也就是说黑客获得了用户的session -id后并不一定
可以利用这个id进行登录，因为对应的session信息可能已经被销毁了，而且session id中也并没有存储其
它有价值的信息，这就是session比单纯的cookie安全性更高的原因
补充：
——session id可以被截获吧 非法用户可以伪装
——所以现在都要用 https 协议了呀，这样你就拿不到这些信息了。
——另外，服务器还可以开启 ip ua 等检验，你的 ip 是无法模拟的。
104.SpringMVC的      CommonsMultipartFile.transferTo()解析:
(1)会覆盖删除同名文件夹!
(2)会覆盖写入同名文件, 而不会抛文件存在异常.
103.count()聚合函数不能和limit同时使用，否则将产生非预期查询结果，如null！
首先明确count()查询不到时只会返回0.
因为limit不会制约count()! MySql先单独执行count()，结果为一行数据，之后limit在从这一行数据查询. 
所以limit的offset参数为0时，显示count()结果；>=1是结果为null(Empty set)！
102.afterPropertiesSet()和自定义init-method、destroy()和自定义destroy-method可以共存，按所写先后顺序执行.
101.BeanPostProcessor和InitializationBean区别：
相同点——都用于Bean的初始化
不同点——后者是针对于每个Bean进行初始化，前者是所有Bean公有，用于后者初始化的包装过滤.
最先执行的是postProcessBeforeInitialization，然后是afterPropertiesSet，然后是init-method，然后是postProcessAfterInitialization.
100.@Configuration用法详解：
1)@Configuration由@Component继承而来，所以两种注解都可以被ComponentScan扫描到识别，这是两者相似的一点. 但@Configuration不在扫描包下也可被Spring识别加入容器，所以配置类可以放在单独config文件夹而不用在Component中指定扫描.
2)@Configuration与@Bean搭配使用，用于使被注解类替代xml配置文件，没有使用次数限制.
故项目中一般写多个配置类文件，便于管理：
SpringConfig.java——@Configuration+@Component(+@Import)，
空类，等效Spring的xml配置文件主体.
SpringMVC.java——@Configuration+@Component(+@Import)，
空类，等效SpringMVC的xml配置文件主体.
MybatisConfig.java....(更多)——
@Configuration(或省略)，
类内含@Bean方法，等效xml的<bean>标签，通过被扫描注入到以上两个主配置文件中.
3)@Configuration和@Component本质区别：
有@Component 注解的类 里面带有@Bean注解的方法在每次被调用的时候都会直接调用方法生成新的实例，这样也违反了spring的单例原则
有@Configuration 注解的类 里面带有@Bean注解的方法在每次被调用的时候会走cglib的动态代理对象，第二次调用对方法进行拦截，从BeanFactory中获取对象从而返回单例.
4)@Bean 注解默认作用域为单例 singleton 作用域，可通过 @Scope(“prototype”) 设置为原型作用域. 承接第3条，@Configuration+@Bean可以做到单例和多例，而@Component+@Bean无法做到单例.
5)@bean方法用于引入第三方bean(因为第三方jar包中的类可能没有使用@Component等注解，你也不可能修改人家源码添加，需要手动new或调用工厂方法)，而这些bean多为jdbc配置类对象，一般要求单例共享.
备注：自己项目内的bean对象一般用@Component/Controller/Reposity/Service注解创建(@Bean方法也行，但不够方便).


99.Spring中基本类型和String都属于简单类型(区别于Java原生类型)，使用"value="而不是"ref=".
98.
当Bean为单例时，Bean归Spring容器管理，Spring容器关闭，就会调用Bean的销毁方法
当Bean为多例时，Bean不归Spring容器管理，Spring容器关闭，不会调用Bean的销毁方法
97.实体类(entity/pojo/domain; 区别于数据层的dao/mapper)---含有属性/成员变量的类不能使用Spring默认的单例，多并发会出现问题，最好使用prototype
补充：
Request作用域，把实例存储到request对象
Session作用域，把实例存储到session对象中，两者只会在web环境中才会存在。
96.守护线程(父子线程)的使用场景:
main线程并不一定是最后一个退出的线程.
当其它线程处于死循环一直运行时，整个程序(JVM)是无法关闭的.
如果你希望在main线程退出后,所有其他线程也退出.那么你可以把其他线程都设置为守护线程.
95.为什么建议使用Spring封装好的线程池而不是自己手动创建？
线程池注入到spring容器中，让容器帮我们创建和管理线程池避免线程池的频繁创建和关闭.
94.@Async 失效问题：
1.不要定义为static类型,这样异步调用不会生效
2.方法必须是public方法。
3.标注@Async注解的方法和调用的方法一定不能在同一个类下，也就是说，方法一定要从另一个类中调用，也就是从类的外部调用，类的内部调用是无效的，因为@Transactional和@Async注解的实现都是基于Spring的AOP，而AOP的实现是基于动态代理模式实现的。那么注解失效的原因有可能因为调用方法的是对象本身而不是代理对象，因为没有经过Spring容器。
93.脏读：针对于未提交的事务而言
不可重复读：针对于同一记录的修改而言
幻读：对于插入和删除行而言
93.在主键上建立聚集索引保证新记录插入在行尾；只要主键指定AUTO_INCREMENT，本身就是带聚集索引的。
92.byte[]储存字节小文件是没有问题的，但是对于稍大一些的文件就会抛出异常：
Exception in thread "main" java.lang.OutOfMemoryError: Required array size too large
at java.nio.file.Files.readAllBytes(Files.java:3156)
从错误定位看出，Files.readAllBytes 方法最大支持 Integer.MAX_VALUE - 8 大小的文件，也即最大2GB的文件。
91.Arrays.asList()返回的ArrayList和new ArrayList()不是同一个类！它是一个同名私有嵌套类，add()会抛出不支持异常！
90.++i不是原子操作，因为包含：读、加、写，涉及到寄存器，对应三条汇编指令；
但Java语言中一般(非硬性规定)赋值是原子操作，因为虽然包含读、写两个动作，但只需要
一条mov指令即可完成.
89.CAS与synchronized的使用情景:
简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）
于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。
对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。
88.调用wait()方法后会释放掉它锁占用的锁，
而sleep()方法则不会.
87.final变量对于基本类型和不可变对象尤其有用，但对于可变对象可能会造成混乱: 该变量的引用指向不可改变，但对象本身可以改变.
对于后者，是非线程安全的.
86.CAS算法核心在于:CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断(切换至其它线程)，相当于CAS是一条原子指令.
        (或许我们可能会有这样的疑问，假设存在多个线程执行CAS操作并且CAS的步骤很多，有没有可能在判断V和E相同后，正要赋值时，切换了线程，更改了值。造成了数据不一致呢?答案是否定的。)
85.Mysql的select语句查询无上限，但会卡慢.
84.HashMap、LinkList理论上容量无限，取决于JVM内存，ArrayList容量最大为Integer.MAX_VALUE(约21亿，因为分正负).
83.Mysql对应的POJO类和MyBatis的接口函数返回值都应当使用装箱类型而不是基本类型.
否则有可能因为null造成空指针异常和MySql异常(除非数据库设定NOT NULL).
备注：
select语句返回值取决于所查询的字段:
(1)select * 返回值可以用单个或List对象接收. 单个对象在查询不到时为null，如果查询结果超过一个，将抛异常；List对象在查询不到时返回空List，不会为null(它会创建空集合返回).
(2)select 单个字段. 如果该字段是数值类型，有可能返回null.
(3)select count(*). 聚合函数查询不到任何是为0,不会返回null.

其它update、delete、insert等语句返回影响的行数，可以选择void不接收该值.

接受数值类型返回值时，可以选择Integer、Long等.

82.局部变量不一定是线程安全的！
(区别于类成员变量)
引用的对象没有存储在每个线程的本地堆栈中。所有对象都存储在共享堆中。如果本地创建的对象从不逃脱其创建方法，则该线程是安全的。实际上，您也可以将其传递给其他方法和对象，只要这些方法或对象都不使传递的对象可用于其他线程.
也就是说：
 如果该对象没有逃离方法的作用访问，它是线程安全的; 如果该对象逃离方法的作用范围，则不是线程安全的.
81.浏览器输入:
协议号(如http://)+ip号+:+端口号
进行网站访问时，千万不要省略协议号！！
本机的浏览器会自动帮你补全，别人电脑或手机则不会，从而导致无法网站访问！
并且，此方式只能用于连接同一个网络的内网.
80.switch-case调用equal()进行相等比较.
79.正确重写hashCode方法：
【原则】按照equals( )中比较两个对象是否一致的条件用到的属性来重写hashCode()。
{1}. 常用的办法就是利用涉及到的的属性进行线性组合。
{2}. 线性组合过程中涉及到的组合系数自定义即可。
注意，拼接之后的数值不能超过整形的表达范围。
{3}. 公式：属性1的int形式+ C1*属性2的int形式+  C2*属性3的int形式+ …
【技巧】当属性是引用类型的时候，如果已经重写过hashCode()，那么这个引用属性的int形式就是直接调用属性已有的hashCode值。
最典型的就是这个属性是字符串类型的，String类型已经重写了hashCode()方法，所以直接拿来使用即可。
78.Spring基本类型和String都是"value = ".
78.1可以提前引用bean.
ioc容器知道了name为address的属性是非简单类型，它就会暂时跳过address属性的赋值以及Student对象的创建，转而去配置文件的下文去找bean标签id值等于ref属性值的对象.
77.如果一个注解中有一个名称为value的属性，且你只想设置value属性(即其他属性都采用默认值或者你只有一个value属性)，那么可以省略掉“value=”部分。
例如: Query有两个属性，value和encoded，encoded有默认值，所以可以不赋值。就只剩下value属性了，当只有一个属性时，可以不用写属性名称，直接赋值。
76.关于代理：
0.Proxy.newProxyInstance()参数2必须为接口,不能是子类,否则运行时异常.
Invocation.invoke()进行实际调用(invoke)不能使用第一个参数，否则造成循环调用！调用对象应该通过构造参数传入，所以Poxy是一个代理类，它代理的是一个对象.
1、JDK原声动态代理时java原声支持的、不需要任何外部依赖、但是它只能基于接口进行代理(因为它已经继承了proxy了，java不支持多继承)
2、CGLIB通过继承的方式进行代理、无论目标对象没有没实现接口都可以代理，但是无法处理final的情况(final修饰的方法不能被覆写)
75.重大误区修正：
Java函数重载和C++一样，允许返回类型不同！
不要与类继承的成员函数覆盖搞浑：
函数覆盖要求返回类型一样，或者是子类型(协变)
74.内部类拥有this指针，this.字段访问的是内部类字段;   内部类访问外部类字段:外部类.this.字段.
74-.方法的形参名和局部变量均会屏蔽同名字段，但两者不能同时存在，否则报重复定义.
73.wait()线程会进入休眠，同时自动释放对象内部锁，使得其它线程可访问此对象.
72.多线程编程的核心思想：
若多线程都是CPU密集型，它将无法获得性能的提升；如果程序CPU计算和IO混合，多线程允许它们重叠运行，从而提升性能.
注意：对于多核处理器，多线程总是有益的.
71.如果一个注解当中有属性，那么必须给属性赋值（除非该属性使用default指定了默认值）
    如果一个注解的属性的名字是value的话，在使用的时候，该属性名可以省略。属性名是其它的时候不能省略。
70.关于localhost的socket:
127.0.0.1 本机网络 IO 不经过网卡
本机网络 IO 过程除了不过网卡，其它流程如内核协议栈还都得走。
补充：
粘包拆包一般是发生在TCP协议层的，TCP作为传输层一般不知道上层（这里指的是我们的代码业务层）数据的具体含义，它会根据TCP缓冲区 的实际情况进行数据包的划分，所以在业务上认为是一个完整的包，可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成 一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。面向流的通信是无消息保护边界的。
69.当程序执行完成以后，再次执行就会报，端口占用异常原因：(java.net.BindException: Address already in use: connect)
明明上一个Socket已经关闭了，为什么再次使用还会说已经被占用了呢？如果你是用netstat 命令来查看端口的使用情况：
   netstat -n|findstr "55533"
   TCP 127.0.0.1:55534 127.0.0.1:55533 TIME_WAIT
　　就会发现端口的使用状态为TIME_WAIT，说到这你需要有一点TCP连接的基本常识，简单来说，当连接主动关闭后，端口状态变为TIME_WAIT，其他程序依然不能使用这个端口，防止服务端因为超时重新发送的确认连接断开对新连接的程序造成影响。
　　TIME_WAIT的时间一般有底层决定，一般是2分钟，还有1分钟和30秒的。
        所以，客户端不要绑定端口，不要绑定端口，不要绑定端口。
68.Files.exist()可以目录和文件的存在性.
67.Windows下绝对路径有无盘符(D:)均可，
无盘符必须加/, Path自动添加盘符；否则视为相对路径，Path.toAbsolutePath()将转换为：当前项目根目录——无名包/根包 + 此相对路径名!
目录和文件名不区分大小写(显示上区分).
66.缓冲输入流如果你未手动刷新或关闭流，待写入的数据将丢失; 而非缓冲流则不存在此情况.
65.(1)Files.createFile()，若目录不存在或文件已存在，均抛出异常. 所以应先调用Files.createDirectories()创建目录和检查存在性.
(2)Files.createDirectories()可以创建单/多层目录,若目录已存在不会抛出异常. 但但是，存在同名文件名，则无法创建目录并抛出FileAlreadyExistException！
备注：参数是路径不含文件名，否则创建同名文
        件夹！file.getAbsolutePath()是含文件名的.
(3)Files.exists()和notExists()互为相反，它们均可以检测目录和文件，路径中最后一项可以为目录和文件.
64.注意缓冲流read(byte[ ] arr)并不一定会读满arr数组大小(实测确实如此)，它只会将内部缓冲区现所有字节数据立马读取返回. 只有在0字节的情况下才会阻塞.
确保读满数组长度的方法：
(1)if(read() != -1)  //单个读取，直到(文件)流EOF.
(2)while(readLength<length){
    readLength += inputStream.read(data, readLength, length-readLength)
}   //效率较高.
第2种写法很精妙，但极其容易出错！
存在3个易错点：
      =写成<= :将导致数组越界或死循环！
      +=漏写+ :死循环！
      参数3写成length:产生数组越界风险！
63.抽象类构造函数可以为public，但不能实例化.
62.输入缓冲流自动刷新(也没有flush),
      输出缓冲流不要忘记手动刷新.
61.ByteArray..Stream实质上也是一个缓冲流.但与其它缓冲流(缓冲区固定，初始化是指定或默认值))不同的是，它的缓冲区是可以动态增长，这与它要保存所有字节数组的功能有关.
它是一对非常有用的流,可用于截取从socket套接字中获取的长连接流;或作为中介流，实现诸如将ObjectStream写入的序列化对象转换为字节流等.
60.1.缓冲流的关闭，先关闭外层的流，再关闭内层的流,但是在关闭外层流的同时，内层流也会自动的进行关闭，所以对于内层流的关闭，可以省略，也就是关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也 会相应关闭内层节点流.
60.将底层stream封装为同类型的高级流，不会使底层流失效，两者可以同时使用.(注意前提是：封装为相同类型的流；字节流和字符流是两种不同类型的流——字节流封装为字符流时，字节流失效！)
但需要注意的是缓冲流，它会把本次输入全部缓冲完直到缓冲区满，导致底层流读不到字节，造成"封装流使底层流失效"的假象.
59.InputStreamReader和Reader区别：
     前者继承于后者，后者是一个抽象类！
58.
关于Mybatis参数注解：












*总而言之，
单参数情况下，
基本类型、POJO和Map注解可以省略，可以直接使用属性；(如果你手贱非要写成xx.属性，POJO和Map也要加注解！)
其它类型最好一律加上. 
注意：单参数String类型也要加注解@Param！
(因为String不属于Pojo类，并且POJO是通过get/set()属性注入，String没有这些方法)
多参数情况下，
所有类型一律加上注解！
注意：这是说的是Mybatis,不是SpringMVC！
且array指的是[ ]数组,不要和ArrayList(集合)弄混.
58.2关于SpringMVC注解：
(1)数组需要加@ResponseBody，否则传参报错！
57.1使用字节流处理中文，如果一次读写一个字符对应的字节数(UTF8对应3个，UTF16对应2个)就不会有问题，一旦将一个字符对应的字节分裂开来，就会出现乱码.
(1)"\r\n"是2个字符.
57.2Java(UTF-16)中码点与代码单位区分：
码点代表一个字符，char是一个代码单位.
(对于UTF-16来说，1个char就是2个字节，其它UTF没有码点的概念)
所有单个字符都是一个码点；
单个字符分为普通(中英文)和特殊(emjo等)字符.
普通字符占1个代码单位，
特殊符号占2个代码单位.
charAt(index)返回1个代码单位(char),
codePointAt(index)返回1码点(1或2个char)
注意：index索引值以代码单位计数而不是码点；charAt()在有特殊字符时有可能导致混乱.
57.3
 (1)Java中char和String内部都是UTF-16储存，但可以指定不同字符集进行读取(转换)
 (2)UTF-8英文字符1字节，中文3字节！
UTF-16中英文一律2字节，复杂字符4字节(56条)
所以对于UTF-8，英文字符可以(char)强转成功，中文则不行；对于UTF-16,中英文一律不能(char).
(3)InputStream和InputStreamReader区别:
      前者得到的是byte, 后者得到char.
      因为Java使用的是Unicode编码，所以
      前者通过(char)仍不能得到字符(Unicode是2
      字节)，后者可以得到.
      注：Java中byte才是和C++的char等同，
              而Java中char称为码点.         
(4)UTF8中一个汉字和字母一样算长度为1.
54.JavaScript中{
         name : "obj"
         arr : [ ]
      }
      该对象.arr声明为数组类型，但js属于弱类型语言，类型可变，所以后端接收的arr取决于前端的输入，数字、字符串等类型均可能.
53.delete from tb  where id in ();  //语法错误： in ()不能为空.
52.SpringMVC自动完成Java对象和JSON转换.
51.delete是element关键字！函数名不能是该名字
50.mock模拟后台数据易错点： Mock.mock("http://127.0.0.1:8825/brand/queryAll.do", "get"
	         , function(req, res) {
	          return {
	            	 data : [{
	                     "id" : "3",
	                     "name" : "无涯",
	                 }],
                 "status":"Ok",
                 message:"品牌列表获取成功!",
                 random:"瞎写响应报文"
	             }
	         } 
	     )
此时，axios.then(response)访问响应体数据中的属于应写为：
response.data.data  !  //正确，得到数组
response.data   //错误！获得的是Object对象
同理，
response.data.message
而不是response.message !
48.带有通配符接口的实现类写法：
public interface Sortable<T extends Comparable<T>>   //接口
public class Sort<T extends Comparable<T>> implements Sortable<T>  //实现类
同理，子类写法：
public class SubSort<T extends Comparable<T>> extends Sort<T>  //子类
47.2tomcat服务器：

*Request请求过程：

*web.xml:

*
47.1Web后端技术总览：

*

*

47.2.微服务技术总览：

*

*

*
46.java的+=易错点：
int i = 1;  char c = '1';  String str = "";
str += i + c;   //str="50"; 错误！i+c(49)优先运算导致错误！
str = str + i + c;  //str="11"; 正确写法.
45.青橙项目心得：
不要使用新版本tomcat8.5部署测试！
直接用tomcat7插件.
做这种几年前的项目教程，尽量和老师的旧版本保持一致！！！不要用新版本包和软件！
46.传智健康项目问题解决：
*
44.spring的properties属性文件不能命名为username"！因为系统库中含有该同名变量，其优先被加载读取.
43.关于Maven汇总：
(0)mvn常用命令：
compile: 仅编译，生成.class类文件
test:  编译+测试(断言),生成报告文件
package: 编译+测试+打j/war包到本项目文件夹下
install:     编译+测试+打包到本项目文件夹下+打包jar/war到本地仓库下
(1)作为Maven父项目时，打包方式必须为
(2)Maven当打包方式为war用于网络项目发布时，main文件夹下必须含有"webapp→WEB-INF→web.xml"，否则编译报错.注意名称必须完全相同，不是WEB_INF!(横杠-而不是下划线_)
(3)执行其它指令前，最好clean一下.
(4)SpringBoot运行前需要执行Maven打包命令！
(5)eclipse使用Alt+F5更新项目引用后，运行前需要执行clean+install命令.

42.xml文件注释<-- -->中间不能含有--         

41.0.关于eclipse的使用：
——项目的导入
(1)"Open probject from system file"选项导入则eclipse将视为普通Java项目
"Import..."选项导入eclipse将按照指定项目类型(如maven项目)编译打包.
(2)以下是实践理解总结，网上没有相关讲解：
Dynamic Web Probject是epclipse早期的web项目结构，打包目录(存放项目代码和资源)是WebRoot/(Myeclipse中)WebConent.
Maven是更为先进的现代Web项目结构，打包目录是WebApp.
一个项目中如果同时存在以上两种打包目录，项目按maven类型import导入能够正常运行则(前提！)，则可以删除WebRoot目录，否则进行修改包名等操作会发生bean方法重复等冲突.
如果按"Open probject from system file"导入，eclipse优先视为Dynamic Web项目，WebRoot为打包目录，此时对webapp(屏蔽)目录下的资源修改是不生效的.
(3)以下为猜测：
对于Dynamic Web项目，
eclipse修改代码目录(src)下的包名时是无法同步更新WebRoot下的.class类文件名字，造成新旧文件同时存在，编译打包是产生bean方法重复等报错，需要手动删除旧.class文件.

41.关于eclipse的坑汇总：
(4)不要开启控制台"输出换行"选项，否则卡慢！
(3)Preferences→Java→Installed JREs中任何版本要选择JDK路径而不是JRE路径！否则编译maven项目时报错！  备注：JDK中包含JRE.
(1)eclipse的sql文件中注释格式：-- 注释内容 
    中间含有空格！否则报错！
(2)eclipse新建数据库连接，关键是URL结尾处要连接的数据库名和密码要正确，其它驱动jar包"mysql->mysql_connector-java..."版本和Database栏什么的不重要, 随意.
(3)eclipse出现报错：
The constructor... is ambiguous.
很可能不是在标红行，而在前面的同类型创建对象行中或后面有问题的代码(如行尾忘记加分号;). eclipse太坑了!
41.2mysql有两种注释方式：
多行注释  /*      */  同C++和Java
单行注释  ——  后面必须追加一个空格！否则报错
40.hashCode()与equal():
(1)重写了equals()也必须同时重写此方法
为什么要重写hashCode()方法？
因为一些hash集合中a.hash == b.hash是先决条件，只有相等才会调用equal()方法从而提高集合元素的查找性能. 而hashCode()与equal()默认实现都是根据对象地址.
(2)不建议使用JDK官方提供的通用生成方法Objects.hashCode(...)，因为它们会引发数组的创建，以便传入数目可变的参数， 如果参数中有基本类型，还需要装箱和拆箱 ，只有不太注重性能的情况下使用.
(3)重写hashCode()方法注意点：
根据(1.1)条，最基本原则是保证当对象相等是两者生成的hashCode()也相等.
具体实现是equal()方法中参与比较的字段hashCode()中也要一一对应.
其余的系数可以随意，但影响是生成hash值冲突的概率，从而导致查找性能的下降.
(3)为什么推荐全部使用31相乘用于编写更高的hashCode()函数：
    原因一：更少的乘积结果冲突
    　　31是质子数中一个“不大不小”的存在，如果你使用的是一个如2的较小质数，那么得出的乘积会在一个很小的范围，很容易造成哈希值的冲突。而如果选择一个100以上的质数，得出的哈希值会超出int的最大范围，这两种都不合适。而如果对超过 50,000 个英文单词（由两个不同版本的 Unix 字典合并而成）进行 hash code 运算，并使用常数 31, 33, 37, 39 和 41 作为乘子，每个常数算出的哈希值冲突数都小于7个（国外大神做的测试），那么这几个数就被作为生成hashCode值得备选乘数了。
    　　所以从 31,33,37,39 等中间选择了 31 的原因看原因二。
    原因二：31 可以被 JVM 优化
    　　JVM里最有效的计算方式就是进行位运算了：
    　　* 左移 << : 左边的最高位丢弃，右边补全0（把 << 左边的数据*2的移动次幂）。
    　　* 右移 >> : 把>>左边的数据/2的移动次幂。
    　　* 无符号右移 >>> : 无论最高位是0还是1，左边补齐0。 　　
           所以 ： 31 * i = (i << 5) - i（左边  31*2=62,右边   2*2^5-2=62） - 两边相等，JVM就可以高效的进行计算。
(3)hashCode()方法和equals方法的关系:
一对多的映射关系.
两个对象，
equals()相等，则hashCode()一定相等;
equals()不等，则hashCode()不定;
hashCode()相等，则equals()不定;
hashCode()不等，则equals()一定不等.
39.和Lambda表达式一样，泛型类的<类型>大多数情况下不需要显式指明.只有在个别情况下编译器在泛型类定义这一行报出晦涩难懂的错误，才考虑显式指定参数类型.
38.静态嵌套类和内部类对象的创建：
     Ex.In obj1 = new  Ex.In();  //静态嵌套类
     Ex.In obj2 = new Ex().new In()  //内部类
     Ex  ex =  new  Ex();
     Ex.In obj2 = ex.new In()  //内部类-等价方式2
备注：内部级类必须依附顶级类对象而存在.
所以创建内部类必须要先创建一个外部类对象，而静态嵌套类则不用.
37.实现控制台"按任意键继续.."：
Java系统自带库没有像C语言getChar()类似的方法，无法做到任意键无回显解除阻塞；所有输入流(如System.out、Scanner)之前需要键入回车才能解除阻塞.所以只能近似实现--"按回车键继续.."
37.1貌似同一次运行中关闭System.out输入流将无法手动new再次开启.
36.Java函数中不允许定义static静态局部变量，但可以定义final常量(C++中是const关键字)，会随着函数调用结束而销毁. 因此多次调用函数此常量值可能不同，只有在同一次调用中值不变.
34.Path的拼接：
Paths.get(String first, String... more)可实现此功能，传入的路径字符串含不含的/或\均可，此函数均可正确处理--添加缺失的或删除重复的/或\.
它会自动删除末尾的/，所以无论多少个"///\\"均不影响Files.isDirectory()或isRegular()判断结果.
34.1Paths.get(String first, String... more)的坑：
(1)要对first和more两个参数判空，并且第二个可变参数不能传入任何null，否则将引发null异常.
(2)传入的字符串开头和结尾不能有空白符，最好先调用trim().
(3)Windows文件系统不支持名字含"?*:等特殊字符，所以传入的路径字符串中除了first主路径可以含:(盘符:)，其它情况下不应该包含这些字符.否则此方法将抛出InvalidPathException.
(4)除了以上3条，可以传入任意字符，即使这显然不是一个路径，如乱码中文.
(5)注意Windows下不能单独写/或\，否则抛异常.
(即该方法获得的是虚拟文件，不一定真实存在)
35.Path的坑:
    (1)中英文字母不一样！这你敢信？
    (2)Path.equal()是覆盖方法，比较的不是地址.
         同一路径，/和\\两种表示法不相等！
33.Files.move()具有一个隐藏功能：重命名目录.
32.JUnit类：
只能且必须有一个0参数的构造函数,否则运行报错.
其它的构造函数可以设为protected/包私有/private.
31.关于==运算符:
1)Java中运算符不能重载，
==默认是比较左右两边的地址是否相等.
2)继承链中的类型变量(父子类)均可以比较.
非继承链中的类型变量不能比较，编译直接报错:
Incompatible operand types...
因为继承链中的类型变量(父子类)均可能相等--运行时动态确定；
非继承链中的类型变量一定不相等--静态确定.
30.Class对象：
1)绝大多数情况下原生Class和泛型Class没有区别.
但泛型类有一个好处：可以静态确定(编译期)一些Class对象(主要是不存在父子关系的泛型类Class)不相等，所以推荐使用泛型类.
2)即使两个类(类名不同)内部实现完全一样，它们的Class对象也不相等.
3)即使两个类的包装类型不同(父子类),两者getClass()获得的Class对象也相等.
探索：
变量.getClass()和类型.class返回的都是泛型Class(Class<T>).不存在父子关系的泛型Class不能进行比较，编译器直接报错(实际上也一定不相等)：
Incompatible operand types Class<capture#..
原因详见31条.
如果两个Class中存在原生Class(Class或Java7以后Class<Object>，两者等价)或两个泛型类有父子类关系，就可以进行比较，即使它们实质类型不相等(Object需要等到运行时才能判断实质类型).
29.如果一个方法由private、Static、final任意一个关键字所修饰，那么这个方法是编译/静态绑定的.
28.String与StringBuild类：
String是不可修改自身的，成员方法不会修改自身且返回拷贝;
StringBuild是可修改自身的，成员方法会修改自身的同时返回自身(不是拷贝!).
两者的相互转换:
两者的new构造函数都支持对方类型的传参，另外StringBuild还可以通过toString()转换为String.
补充：
StringBuild通过new构造函数可以创建String或克隆自身，两者是相互独立的，修改不会影响彼此.
27.一个.java文件可以有多个class类，它们除了包私有——只能被同一个包类访问，和生成的.class文件名带$——表明非public类，其它与public类无异！
26.Arrays.equals()只能比较一维数组.
      Arrays.toString()只能打印一维数组元素值，
      高维以上将打印低一维地址.
25.关于数组类型转换：
数组类型转换分为直接整体转换和逐个元素转化.
(1)整体转换：
所有数组可以直接整体转换为Object；
对象数组可以直接整体转换为Object[ ]，
原生数组需要逐个元素转换为Object[ ]
(基本类型自动装箱为对应的对象类型，
 再自动转换为Object类型)；

对象数组整体转换为元素父类型数组，
可以自动隐式整体转换.
对象数组整体转换为元素子类型数组，
需要强制转换，前提本质是子类型.
(否则虽然能骗过编译器，但在运行时将抛出ClassCastException)
(2)逐个转换:                                                       
以下两种情况只能遍历逐个元素转换.
*数组整体转换不支持自动装箱和拆箱,
(或者说原生类型与装箱类型不存在父子类关系)
即原生数组和对应装箱数组不能直接整体转换.
*数组整体转换不支持自动转换为长类型.
    如：int[ ] -> double[ ]  
            Integer[ ] -> Double[ ]  //Integer类和Double类             
            //不是父子类关系，它们公有父类是Number
    以上两种情况不能自动隐式转换,也不能强转，
    否则编译报错或抛出异常!
    根本原因在于类型转换只存在于父子类关系中.
24.getClass()和instantof均按实质类型判断，而不是包装类型. 所以不需要强转.
23.1克隆方法clone()：
(0)Object.equals()是protected,每个子类需要覆盖此方法才能被所有外部类调用，否则只能被自己和子类内部调用，这显然是无意义的.
(1)完美clone()编写步骤:
 *   首先本类声明implements Cloneable标签接口.
 *   public 本类类型  clone(){ //协变返回类型
 *    本类类型 cloned = (本类类型)super.clone();
 *    cloned.新对象成员1 = 成员.clone()/new 构造器(新对象成员1值);                                               
 *      cloned.新对象成员2 = 成员.clone()/new 构造器(新对象成员2值);
 *      ....
 *      return cloned;
 *   } 
 *   设计规范:父子类每个类只管自己新声明成员的拷贝.
 *           super.clone()不是一般意义的super()方法，内部实现是重写从内存复制当前所在类的类对象(this)，所以可以直接强转并访问当前子类的新成员而不会抛出异常.
 *           都需要重写clone(),不要让继承链中的重写clone()发生断裂--将导致后面的clone()失效,
 *           即对象成员存在浅拷贝,未相互独立,存在耦合.
23.equals()与==运算符：
(0)Object.equals()是public,默认实现与==语义相同.
(1)Java中 == 比较的是两个对象的地址，而equals()Object类的默认实现也是使用==比较地址.
==是狭义的"相等"："地址相同必定是同一个对象同一个对象必定相等"，这固然没错，但通用性太小. 
广义的"相等"：无论是否同一对象，只要其内容/类成员相同，就认为两者相等.
(2)重新实现equals()方法的的意义在于将从Object类继承的狭义相等变成广义相等.
对于基本类型，它们是常量--地址不会改变，狭义和广义相等是一致的，所以==运算符是没有问题的.
如果类成员存在非基本类型(String)，就需要使用equals()而不是==运算符.
易错点：覆盖equals()形参类型必须是Object而不是本类类型！但返回值可以是本类类型(协变类型)
(3)关于String的equals()和==:
Java字符串创建主要有三种方式--
    1)String str = "string";
    2)String str = new String("string");
    3)拼接
       <1>String str = "str" + "ing";
       <2>String tmp = "str",
                         str = tmp + "ing";
    4)静态方法String.valueOf(), 本质同1)条
   第一种是字符串常量，相同字符串地址必定不变；
   第二种不是字符串常量，每次new不管字符串常量池中是否有相同字符串，都会创建一个新对象放在堆中，所以相同字符串地址必定会变.
   (备注：此方式创建传入null时将抛出null异常！)
   第三种又分为两种情况：第一小种是字符串常量，同方式一；第二小种不是字符串常量，同方式二.所以相同字符串地址可能会变.
   综上所述，因为内容相同字符串地址可能会变(难以确定字符串变量创建之初是否为常量)，==比较的结果是不稳定易变的，所以字符串应该全部使用equals()成员方法进行比较.                               
(4)String和八大装箱类型均重新实现了equals()，所以比较相等时不要用==运算符!
如果要求广义相等(99%情况)，所有的对象/引用类型均应该使用覆盖后的equals()方法.      
==运算符只在比较原生类型或判断是否同一对象(地址相等)/狭义相等这两种情况下使用！     
(5)反射中Field覆盖实现了equal()，但内部实现通过成员类型和成员名字比较相等，与内容(值)无关，不属于广义相等(也不是狭义相等--比较地址).
(6)完美equals()编写步骤:
 *   public boolean equals(Object otherObject){  
 *       (1)if(this == otherObject) return true;  //优化效率, 可有可无
 *       (2)if(other == null) return false;   //若步骤(4)调用.getClass(),是很有必要的! 否则抛出空指针异常.  若步骤(4)调用instancceof,则没有必要,可不写.
 *       (3)(可省略)if(!super.equals(otherObject)) return false;  //比较父类所有成员相等性
 *          如果父类的equals()方法是从Object类继承的默认equals(),就禁止调用此语句.
 *          否则此语句的调用就很有必要,使得子类可以只专注自身新声明的成员的相等比较,不用再管父类成员.
 *          (其实子类也管不到父类私有成员,所以才有super.equals()的必要)
 *       (4)//此步骤为下面的强转转换做准备
 *          if(this.getClass() != otherObject.getClass()) return false; //写法1
 *          if(!(otherObject instanceof 本类类型)) return false;        //写法2
 *          写法1满足对称性原则, 优先采用. 
 *          适用于父子类语义改变--子类覆盖equals(),需要进行自身新声明成员的比较的情况.
 *          缺点只能在同一种类之间比较,对不适用于"父子类语义相同,且需要父子类进行比较"的情况.
 *          写法2违反对称性原则, 极少采用.
 *          适用于父子类语义保持不变,且需要父子类进行比较的情况.
 *          此写法应当在方法声明前加上"final"关键字,让父子类共用父类的equals()方法--语义不变,
 *          同时可以让编译器协助检查,防止子类覆盖equals()方法而导致语义改变.
 *          写法1和写法2相互弥补,根据实际情况选用.
 *       (5)本类类型 other = (本类类型)otherObject;  //参数强制转换
 *       (6)return this.成员1==other.成员1() 
 *               或Objects.equals(this.成员1,other.成员1()           //自己类可以直接访问other私有成员，无需使用get()方法，提升性能.
 *              && this.成员2...                 
 *           注意点：
 *        1.虽然无论原生类型对象类型均可以统一
 *            调用Objects.equals()，但是原生类型最好
 *            还是使用==比较，避免自动装箱开销从而
 *            提升算法性能.
 *         2.对象类型不要使用成员1.equals(成员2)
 *            进行相等判断！因为有可能抛出null异常.
 *            应使用Objects.equals()判断--其内部实现    
 *            有判空.
 *   }
 *   设计规范:如果本类新增对象/引用成员,应重写equals(),
 *           不要让继承链中的重写equals()发生断裂,
 *           否则将使用最后一次equals()覆盖版本,中间未重写equals()的类的成员将不参与比较,
 *           将有可能导致后续的equals()比较结果错误!
 *           (尤其是这些中间类存在私有成员且设置了get和set方法,
 *            set方法改变中间类私有成员,后续子类if(equals())返回结果是相等,再通过get方法获取私有成员,
 *            竟然是不相等!这在大型程序中将引发难以排查的严重错误!)
22.函数式接口中只能有一个抽象方法，但可以有任意个默认方法，因为它们可以不需要额外实现.
21.对于接口默认方法，在子接口中可以:
(1)什么也不做，默认继承此相同方法.
(2)声明此默认方法，将其重新实现.
(3)声明为abstract，重新变为抽象方法.
20.关于Lambda表达式变量作用域：
Lambda体式内this属于调用成员方法所在类.
20-.Java函数体内声明的局部变量不能屏蔽同名形参，所以两者不能同名，这样的设计有效抑制了代码可读性的降低.
19.Lambda 表达式实现的接口不是普通的接口，而是函数式接口——有且只有一个抽象的方法，那这个接口就是函数式接口. 使用@FunctionalInterface注解，可以让编译器协助检查：如果函数式接口中声明了多个参数方法，那么编译错误:
The target type of this expression must be a functional interface！
18.3抽象类不能使用lambda式和方法引用,即使抽象类和函数式接口完全相同.
猜想：因为lambda式和方法引用会生成临时对象，而抽象类不能被实例化.  
——猜想错误！因为两者的本质不同.
18.2lambda表达式与匿名局部类在捕获(也只能捕获; 成员变量不能被捕获)方法体内局部变量只能是最终事实final变量，并不能对其进行修改. 区别于传入的形参——可以修改.
(注意：是指引用指向不能修改，所引用的对象内部仍然可以修改)
该限制是为了保证多线程安全，因为接口方法不能添加"synchronized"关键字，这就无法保证实现该接口的方法是同步的.
而(非静态非匿名)内部类可以引用外部类的成员变量，并允许对其修改.
18.1Lambda表达式实质是函数，而匿名类的实质是类对象，这也是为什么函数式接口只能有一个方法的原因. 因为没有类实例化与销毁过程，所以lambda表达式在系统冷启动效率比匿名类高一些.
18.2方法引用(::)实质是Lambda表达式进一步的简化，当Lambda式体内只有一个方法调用(即1个表达式)且该方法的形参和返回值一致时，可以直接写为方法引用，简化代码的同时具有更强的可读性.
18.Lambda表达式写法：
(形参1，形参2..)—>{
      语句1;
      语句2;
      ....
      return 返回值;
}
说明：
(1)如果形参为1个时，()可以省略，其余情况下必须保留().
(2)形参类型大多数情况下不用指定，编译器通过所调方法的参数接口类型的参数类型确定.
(3)与C++不同，Java不需要指明返回值类型.
(4)当Lambda体内只有一个表达式/语句时，可以省略{ }，此时"return"关键字和语句后的分号(;)也必须一同省略.                                                
(5)最简式：()—>表达式  或  参数1—>表达式                      
15.强制转换只存在于继承链(父子类)中,不在继承链中的强转编译器直接报错！(实质上也一定转换失败)
子类可以自动隐式转换为父类，
强制转换的使用场景是父类转子类.   
强转之前应使用instanceof进行检查，避免抛出异常. 只有当包装类型是父类，实质是子类才会强转成功,否则即使编译通过，但运行时抛出强转失败异常!
15.1子类 instanceof 父类--true
        父类 instanceof 子类--false
        (注：实质类型)
任意子类都是父类的实例；
反之不是，即使单纯继承,没有新增任何属性和方法.
instantof检验与是否能强制转换是一致的，false是仍强转必定抛出ClassCastException异常！
14.子类数组可以直接隐式转换为父类数组，因此程序员自身要保证数组元素类型的一致性，不要将实质子类类型中的数组混入父类类型，这扰乱数组存储空间而引发异常.
13.关于反射机制：
反射中getFields/Methods/Constructors()和getDeclaredFields/Methods/Constructors()区别:
前者获取所有自身和(多层)父类继承的公共XX,
后者获取所有自身声明定义的私有/保护/公共XX.
1)后者从父类默认继承的XX将不被打印！(即使是父类public成员)除非显式将方法覆盖、成员变量屏蔽. 因为在继承机制中默认继承的方法、变量视为属于父类！它们不属于自身声明定义.
2)进一步的，对于协变类型的覆盖方法，无论前后者，根据权限修饰符，要么同时打印两个该同名方法，父类的会额外加volatile关键字；要么同时不打印.  非协变类型覆盖方法，仍同1)条.
3)反射对于类字段按固定顺序存取，
           对于类方法随机存取！
易错点：获取指定类成员变量时，如果抛出"NoSuchFieldException"异常，请检查是否尝试用getMethod(name)获取保护/包私有/私有成员.如果是，请改为getDeclareMethod(name).           
13.1反射getName()方法对于数组:
   基本类型 int[ ]-"[I"  double[ ]-"[D"
   包装类型 Integer[ ]-"[L+类型名全称(java.lang.Integer)"
   "[["表示二维数组，"L"表示一个对象
13.2反射获得多维数组的低维元素(数组)的函数:
Array.get()--返回值强制转换回原类型.
13.反射中Field.getName()可以获得成员变量原名字
     Parameter.getName()只能获得arg0、arg1...
因为成员变量可能被外部访问，并且获得原名更有意义；而函数形参名只在局部域使用，可以随意替换，并且获得形参原名无太大意义，因为形参名不代表实参名.
13.4通过反射无法达到super.父类方法()的效果：
通过getSuperclass()获得父类Clas，再通过getMethods()获得父类方法，此时invoke()调用此方法，仍按实质类型(子类)调用(如果子类覆盖了此父类方法，将仍调用的是子类方法).
7.父子类继承关系中，只有父类的公有和保护成员/方法将会被继承.父类的保护成员/方法很特殊，亲测：包内的所有类(无论是否父子类)均可以访问，不同包只能通过子类自身访问(其实子类就是访问自身继承而来的成员/方法).       
同时，因为在继承机制中默认继承的方法、变量视为属于父类！除非子类重新实现覆盖. 所以对于默认protected方法，外部类有可能是可见调用的！取决于父类的所在包的位置.
但protected方法对子类一定可见.              
误区：1.(不同包)子类方法中new创建父类对象，直接访问其保护成员/方法是不行的，这相当于外部直接访问. 应该通过this.保护成员这种内部方式访问.    
    2.本类方法可以直接访问传入同类参数或函数体内new创建同类对象的私有成员/方法及以上！这和第1点一样也是相当于外部直接访问.
    3.造成第1点和第2点差异关键在于可见性.
    现在总结，我们把函数传入参数或函数体内new创建同类对象的私有成员/方法成为"外部对象".
(1)己类可以直接访问"外部对象"所有修饰符成员
/方法；
(2)同包其它类可以直接访问"外部对象"包私有及以上成员/方法；
(3)不同包非子类，不能直接访问"外部对象"任何成员/方法(除了public)，特别是保护方法.不同包子类只能只能通过this内部访问保护成员/方法. 这是protected权限的特殊性所在——难以准确理解.
           包私有成员/成员对于己类、同包所有类；
 只能通过内部this访问的有：
           保护成员/方法对于子类
7.1关于继承的深入探讨:
    实质上, 父类所有的成员都会被子类继承!!
 只是public和protected对于子类可见的,视为继承;
 其它不可见成员(private和包私有)视为不会被继承.
         同一个包内new子类.包私有成员可直接证明、
         调用子类只能调用父类super构造器而不能覆盖
         可间接证明、
         类的"未继承/私有成员"可以通过的公有/保护方
         法修改,间接证明、
         "父类所有的成员都会被子类继承"的结论.
7.1.1关于类中的覆盖和屏蔽：
(首先，我们把new时声明类型称为实质类型，创建新引用时声明类型称为包装类型.)
覆盖方法按实际类型调用，而不是包装类型调用.包装类型为父类的子类对象调用该方法的最后一个"重载"版本，产生覆盖父类方法效果. 
用该方法的最后一个"重载"版本——这就是多态性的本质定义！
屏蔽方法按包装类型调用. 静态方法和静态成员可以被继承，子类没有"重载"该同名静态方法时，会调用父类的静态方法；当子类含有同名同参数列表静态方法时，会调用子类自身这个方法，产生屏蔽父类方法效果.
覆盖/多态性是对于实例方法而言，
屏蔽是对于类静态方法、成员(无论非/静态)而言.
(备注：父子类同名成员可以类型不同，所以是屏蔽效果.)
补充：包装类型编译期就确定，实质类型只有运行时才确定，这是多态性的实质二.
(1)子类重新实现父类的方法称重写；重写时可以修改访问权限修饰符和返回值，方法名和参数类型及个数都不可以修改；仅当返回值为类类型时，重写的方法才可以修改返回值类型，且必须是父类方法返回值的子类；要么就不修改，与父类返回值类型相同。
7.2关于类的get()和set():
通常情况下，get()方法应当返回成员变量的克隆,
成员变量的修改应该通过set()方法规范约束起来.
get()返回成员自身或设为public直接对成员访问修改会极大破坏类数据的封装性.
易错点：get()返回克隆时注意判空，避免.clone()抛出NullPointerException异常.
为什么要get()和set()方法？
1).提供接口方法，可以随时删除、修改或替换该成员而保持对外不变，仍然保持数据一定的封装性.
2).get()可以控制变更对输出的格式，
   set()可以控制输入格式，对输入合法性进行检查，如：避免null值的传入. 如果直接设为public成员，每次都要手动检查一遍null，非常麻烦.
3).面向对象类设计对成员访问修改的统一风格.
12."string" + va 不要画蛇添足调用显式调用变量va.toString()，变量var有可能是一个null！
Java已经重载+运算符，(可能)自动隐式调用String.valueOf()静态方法--当var为空引用时可以直接转换为"null"字符串，否则调用toString()方法.
19./**
 * 关于枚举类:
 * 1.枚举类首先声明枚举常量,
 *   才能声明字段和方法, 否则报莫名其妙的错误.
 * 2.枚举常量默认都是public static final, 
 *   所以不用加也不能加final、static和public等修饰符.
 * 3.枚举类的构造器只能是私有或包私有, 不声明权限修饰符默认包私有.
 * 4.枚举类默认为final类,不能被继承,不用也不能声明final关键字.
 * 5.枚举类型的成员变量和成员方法可以是任意权限修饰符.
 * 6.switch-case中只需写元素名,无需也不能写完整类+元素名.
 * 7.普通类或枚举类中可以再嵌套枚举子类,可以使用任意权限修饰符.
 * 8.如果未重载println()方法,将利用反射打印的是元素自身的名字.
 * @author XM
 */
11.Java类成员可以是自身类型，且可以通过set方法或this指向自身，此时是循环引用状态.另外类成员也可以是子类类型，此时也是循环引用状态. 
这样的类设计是不合理的，容易造成构造函数和equals()等方法的循环调用. 所以一个设计合理的类不应该含有自身类型和子类成员.
10.类静态成员在同一次运行中被修改值会保持不变，所以若反复多次使用注意做好归零清理工作.
9.try{}语句块中抛出异常，则块中剩余的语句不会执行，即使catch捕获并解决了异常.
所以try{}语句块中尽量只写抛出异常语句，正常语句应放在块外面.                           
注意：finally子句不要写改变控制流的语句(return、break、throw、continue)，但try和catch子句中可以写.
8.可变参数与数组参数的区别:
      1.可变参数的函数可以不传任何参数，视为隐式创建传入一个空数组(元素个数为0的数组，不是null)；其参数位置必须是最后一个；可接受一个数组或0或多个未封装数组元素，非常方便.(可变参数只能存在一个，即使类型不同可以区分)
 注意：Cls(int id)  //构造器1
       和  Cls(int id, String... name)  //构造器2
 当构造new Cls(5)时并不会产生二义性,因为根据参数最佳匹配原则，未传入空数组，所以构造器1优先于构造器2.
      2.数组参数必须传入一个参数;只能接受数组封装；但参数位置可以任意.
除此之外，两者相同，均可以接收(空)数组、null参数，内部转为数组处理.
6.内部类访问外部同名变量/方法：
   外部类名.this.变量/方法()
备注--
"变量/方法()"调用的是内部类(隐式this)，
"外部类名.变量/方法()"调用的是外部类的静态变量/方法.
5.空数组(元素个数为0)不是null.
例如：var i= new String[0]不是null，但i[0]会越界.
4.集合的subList()返回的是List<>接口类型，而不是原本的集合类型，且不能强转为原来类型.
3.抛出非检查型异常(Error和Exception->RuntimeException及其子类)时，在方法名声不声明“throws 异常”均可，即使声明了，调用它的函数依然可以无需声明异常.
3.1抛出检查型的异常(Exception->IOException)时，要么方法名声明异常，要么捕获异常，否则编译错误. 两者同时做没有意义.
2.断言为假时才抛出异常.
断言类似于“静态编译检查”，它负责代码逻辑错误的检查；而语法错误由编译器检查补足.
1.new[length]数组除了8种基本类型(String不是), 初始值都是null！